{
  
    
        "post0": {
            "title": "Return period",
            "content": "Bilbao, today . Bilbao, August 1983 . more photos . On Friday, August 26, 1983, Bilbao was celebrating its Aste Nagusia or Great Week, the main annual festivity in the city, when it and other municipalities of the Basque Country, Burgos, and Cantabria suffered devastating flooding due to heavy rains. In 24 hours, the volume of water registered 600 liters per square meter. Across all the affected areas, the weather service recorded 1.5 billion tons of water. In areas of Bilbao, the water reached a height of 5 meters (15 feet). Transportation, electricity and gas services, drinking water, food, telephone, and many other basic services were severely affected. 32 people died in Biscay, 4 people died in Cantabria, 2 people died in Alava, and 2 people died Burgos. 5 more people went missing. . How often will such rainfall happen? . How often does it rain 50 mm in 1 day? What about 100 mm in 1 day? How big is a &quot;once-in-a-century event&quot;? . Let&#39;s examine Bilbao&#39;s daily rainfall (mm), between 1950 to 2020 . import matplotlib.pyplot as plt import numpy as np import pandas as pd from functools import reduce import re import probscale from pandas.plotting import register_matplotlib_converters register_matplotlib_converters() . %matplotlib notebook fig, ax = plt.subplots(figsize=(10,6)) df = pd.read_csv(&quot;daily-data/BILBAO-parsed&quot; + &quot;.csv&quot;, sep=&quot;,&quot;) df[&#39;full-date&#39;] = pd.to_datetime(df[&#39;full-date&#39;]) df = df.set_index(&#39;full-date&#39;) ax.plot(df[&#39;rain (mm)&#39;], &#39;-o&#39;, label=&quot;daily rain (mm)&quot;) ax.set_xlabel(&quot;date&quot;) ax.set_ylabel(&quot;daily rainfall (mm)&quot;) ax.set_title(&quot;Hyetograph -- Bilbao, Spain&quot;) plt.gcf().autofmt_xdate() . How much rain did it fall around August 26, 1983? . %matplotlib notebook fig, ax = plt.subplots(figsize=(8,6)) one_week = df.loc[&#39;1983-08-21&#39;:&#39;1983-08-28&#39;, &#39;rain (mm)&#39;] ax.plot(one_week, &#39;-o&#39;, label=&quot;daily rainfall (mm)&quot;) plt.gca().set(xlabel=&#39;date&#39;, ylabel=&#39;daily rainfall (mm)&#39;, title=&quot;week of 1983-08-21 to 1983-08-28&quot;) plt.gcf().autofmt_xdate() print(one_week) print(&quot;rain during 1 week: &quot; ,one_week.sum() , &quot; (mm)&quot;) . full-date 1983-08-21 1.2 1983-08-22 27.9 1983-08-23 10.0 1983-08-24 22.0 1983-08-25 44.8 1983-08-26 252.6 1983-08-27 91.6 1983-08-28 1.1 Name: rain (mm), dtype: float64 rain during 1 week: 451.19999999999993 (mm) . Let&#39;s rank the annual max . %matplotlib notebook fig, ax = plt.subplots(figsize=(10,6)) # resample daily data into yearly data (maximum yearly value) max_annual = pd.DataFrame(df[&#39;rain (mm)&#39;].resample(&#39;Y&#39;).max()) # sort yearly max from highest to lowest max_annual = max_annual.sort_values(by=[&#39;rain (mm)&#39;], ascending=False) max_annual[&#39;rank&#39;] = np.arange(1, len(max_annual) + 1) print(max_annual) # plot annual max vs. rank ax.plot(max_annual[&#39;rank&#39;], max_annual[&#39;rain (mm)&#39;], &#39;-o&#39;) plt.gca().set(xlabel=&quot;rank&quot;, ylabel=&quot;annual max (mm)&quot;) . rain (mm) rank full-date 1983-12-31 252.6 1 1953-12-31 172.6 2 1963-12-31 143.5 3 1959-12-31 137.2 4 2010-12-31 108.1 5 ... ... ... 2003-12-31 41.1 70 1972-12-31 37.1 71 2001-12-31 32.9 72 1999-12-31 32.1 73 2020-12-31 30.5 74 [74 rows x 2 columns] . [Text(0, 0.5, &#39;annual max (mm)&#39;), Text(0.5, 0, &#39;rank&#39;)] . Ward, Environmental Hydrology, pages 46-47 . $$ F_a = frac{100(2n-1)}{2y} $$$$ text{Return period} = frac{100}{F_a} $$ %matplotlib notebook # number of events y = len(max_annual) n = max_annual[&quot;rank&quot;] max_annual[&#39;Fa&#39;] = 100 * (2*n-1) / (2*y) max_annual[&#39;return period (yr)&#39;] = (2*len(max_annual)) / (2*max_annual[&#39;rank&#39;]-1) max_annual[&#39;weibull&#39;] = (y+1) / n . # from matplotlib.ticker import ScalarFormatter fig, ax = plt.subplots() ax.plot(max_annual[&#39;rain (mm)&#39;], max_annual[&#39;Fa&#39;], &#39;o&#39;) # ax.plot(data[&#39;return period (yr)&#39;], data[&#39;depth (cm)&#39;], &#39;o&#39;) ax.set_xscale(&#39;prob&#39;) ax.set_yscale(&#39;prob&#39;) ax.set_xlim([10,98]) plt.gca().invert_xaxis() . Return Period . Brutsaert, &quot;Hydrology, an introduction&quot;, page 513 . $F(x)$ is the CDF of the PDF $f(x)$. $F(x)$ indicates the probability that a certain event above $x$ has not occurred (or that an event below $x$ has occurred, same thing). . $1-F(x)$ is the probability that a certain event above $x$ has occurred. It&#39;s reciprocal is the return period: $$ T_r(x) = frac{1}{1-F(x)} $$ . This return period is the expected number of observations required until $x$ is exceeded once. In our case, we can ask the question: how many years will pass (on average) until we see a rainfall event greater that that of 26 August 1983? . Let&#39;s call $p=F(x)$ the probability that we measured once and that an event greater than $x$ has not occurred. What is the probability that a rainfall above $x$ will occur only on year number $k$? . it hasn&#39;t occurred on year 1 (probability p) | it hasn&#39;t occurred on year 2 (probability p) | it hasn&#39;t occurred on year 3 (probability p) | ... | it has occurred on year k (probability 1-p) | . $P {k text{ trials until }X&gt;x } = p^{k-1}(1-p)$ . Every time the number $k$ will be different. What will be $k$ on average? . $$ bar{k} = displaystyle sum_{k=1}^{ infty} k P(k) = displaystyle sum_{k=1}^{ infty} k p^{k-1}(1-p)$$ . Let&#39;s open that up: . $$ begin{align} bar{k} &amp;= 1-p + 2p(1-p) + 3p^2(1-p) + 4p^3(1-p)+ cdots bar{k} &amp;= 1-p + 2p - 2p^2 + 3p^2 - 3p^4 + 4p^3 - 4p^4+ cdots bar{k} &amp;= 1 + p + p^2 + p^3 + p^4 + cdots end{align} $$For $p&lt;1$, the series converges to $$ 1 + p + p^2 + p^3 + p^4 + cdots = frac{1}{1-p}, $$ therefore $$ bar{k} = frac{1}{1-p}. $$ .",
            "url": "https://yairmau.com/jupyter/2020/02/01/returnperiod.html",
            "relUrl": "/jupyter/2020/02/01/returnperiod.html",
            "date": " • Feb 1, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Hydrology --- introduction",
            "content": "How much water is there? Where? . https://prd-wret.s3.us-west-2.amazonaws.com/assets/palladium/production/s3fs-public/styles/full_width/public/thumbnails/image/all-the-worlds-water.jpg . https://www.usgs.gov/media/images/distribution-water-and-above-earth . The water cycle . https://www.usgs.gov/media/images/water-cycle-natural-water-cycle . Global water distribution . Water source Water volume (km$^3$) % of freshwater % of total water . Oceans, Seas, &amp; Bays | 1,338,000,000 | -- | 96.54 | . Ice caps, Glaciers,&amp; Permanent Snow | 24,064,000 | 68.7 | 1.74 | . Groundwater | 23,400,000 | -- | 1.69 | . $ quad$Fresh | 10,530,000 | 30.1 | 0.76 | . $ quad$Saline | 12,870,000 | -- | 0.93 | . Soil Moisture | 16,500 | 0.05 | 0.001 | . Ground Ice &amp; Permafrost | 300,000 | 0.86 | 0.022 | . Lakes | 176,400 | -- | 0.013 | . $ quad$Fresh | 91,000 | 0.26 | 0.007 | . $ quad$Saline | 85,400 | -- | 0.006 | . Atmosphere | 12,900 | 0.04 | 0.001 | . Swamp Water | 11,470 | 0.03 | 0.0008 | . Rivers | 2,120 | 0.006 | 0.0002 | . Biological Water | 1,120 | 0.003 | 0.0001 | . * (Percents are rounded, so will not add to 100) https://www.usgs.gov/special-topic/water-science-school/science/fundamentals-water-cycle . Energy drives the hydrologic cycle . A key aspect of the hydrologic cycle is the fact that it is driven by energy inputs (primarily from the sun). At the global scale, the system is essentially closed with respect to water; negligible water is entering or leaving the system. In other words, there is no external forcing in terms of a water flux. Systems with no external forcing will generally eventually come to an equilibrium state. So what makes the hydrologic cycle so dynamic? The solar radiative energy input, which is external to the system, drives the hydrologic cycle. Averaged over the globe, 342 W m$^{-2}$ of solar radiative energy is being continuously input to the system at the top of the atmosphere. This energy input must be dissipated, and this is done, to a large extent, via the hydrologic cycle. Due to this fact, the study of hydrology is not isolated to the study of water storage and movement, but also must often include study of energy storage and movements. . Margulis, 2017, &quot;Introduction to Hydrology&quot; . Components of the water cycle . Water storage in oceans . Evaporation / Sublimation . Evaporation $ longrightarrow$ cooling . Source: http://www.hk-phy.org/contextual/heat/cha/evapo02_e.html . Source: https://courses.lumenlearning.com/cheminter/chapter/evaporation/ . Source: https://engineeringinsider.org/cooling-tower-types/ . Source: https://slideplayer.com/slide/7418126/ . Evapotranspiration . http://www.eschooltoday.com/water-cycle/what-is-transpiration-and-evapotranspiration.html . Water storage in the atmosphere . Cumulonimbus cloud over Africa . Source: https://commons.wikimedia.org/wiki/File:Cumulonimbus_Cloud_over_Africa_(color).jpg Picture of cumulonimbus taken from the International Space Station, over western Africa near the Senegal-Mali border. . If all of the water in the atmosphere rained down at once, it would only cover the globe to a depth of 2.5 centimeters. $$ begin{align} text{amount of water in the atmosphere} &amp; qquad V = 12 , 900 , text{km}^3 text{surface of Earth} &amp; qquad S = 4 pi R^2; quad R=6371 , text{km} &amp; qquad V = S times h text{height} &amp; qquad h = frac{V}{S} simeq 2.5 , text{cm} end{align} $$ . Condensation . Precipitation . Water storage in ice and snow . Snowmelt runoff to streams . Surface runoff . Streamflow . Lakes and rivers . Infiltration . Groundwater storage . Groundwater flow and discharge . Spring .",
            "url": "https://yairmau.com/jupyter/2020/02/01/introduction.html",
            "relUrl": "/jupyter/2020/02/01/introduction.html",
            "date": " • Feb 1, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://yairmau.com/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "This website's logo",
            "content": ". Introduction . This will only work if you have Mathematica installed in your machine. Python can interface with Wolfram Mathematica, taking advantage of its awesome power. . The curve inside the square is a parabola: $$ y = ax^2 + bx + c $$ . This parabola passes through the points $(0.3, 0)$ and $(1, 1)$, and it&#39;s derivative at $(0.3, 0)$ is zero. We use Mathematica to figure out what are the parameters $a,b,c$. Finally, we transpose the line when plotting, i.e., $x$ is in the vertical axis, and $y$ is in the horizontal axis. . The code . %matplotlib inline import matplotlib.pyplot as plt import numpy as np from wolframclient.language import wl from wolframclient.evaluation import WolframLanguageSession from wolframclient.language import wl, wlexpr w = 20 plt.rc(&#39;axes&#39;, linewidth=w) fig=plt.figure(1, (5, 5)) fig.subplots_adjust(left=0.0, right=1.0, top=1.0, bottom=0.0, hspace=0, wspace=0) ax = plt.Axes(fig, [0., 0., 1., 1.]) fig.add_axes(ax) session = WolframLanguageSession() session.evaluate(wlexpr(&#39;y[x_] := a x^2 + b x + c&#39;)) session.evaluate(wlexpr(&#39;p1 = {0.3, 0}&#39;)) session.evaluate(wlexpr(&#39;p2 = {1, 1}&#39;)) session.evaluate(wlexpr(&#39;sol1 = Solve[ {y[p1[[1]]] == p1[[2]], y[p2[[1]]] == p2[[2]]}, {a, b, c}][[1]]&#39;)) session.evaluate(wlexpr(&#39;sol2 = Solve[(D[(y[x] /. sol1), x] /. x -&gt; 0.3) == 0, a][[1]]&#39;)) par = list(session.evaluate(wlexpr(&#39;{a, b, c} /. sol1 /. sol2&#39;))) x0 = 0.3 x=np.linspace(x0, 1, 1001) a, b, c = par# [2.08163, -1.24898, 0.167347] y = lambda x: a*x**2 + b*x + c c1 = &#39;white&#39; # bottom right c2 = &#39;white&#39; # top left # c1 = &#39;#6c7053&#39; # bottom right # c2 = &#39;#6e0014&#39; # top left # ax.fill_between(y(x), x, y2=0, facecolor=c1, # edgecolor=&#39;black&#39;) # bottom right # ax.fill_between(y(x), x, y2=1, facecolor=c2, # edgecolor=&quot;black&quot;, linewidth=10) # top left ax.plot(y(x), x, color=&quot;black&quot;, lw=w) ax.set_xlim([0,1]) ax.set_ylim([0,1]) ax.set_xticks([]) ax.set_yticks([]) fig.savefig(&quot;./python_figures/site-logo.png&quot;, resolution=600, transparent=True, bbox_inches=&quot;tight&quot;) fig.savefig(&quot;./python_figures/site-logo.svg&quot;) plt.show() . Equations may not give solutions for all &#34;solve&#34; variables. Equations may not give solutions for all &#34;solve&#34; variables. . session = WolframLanguageSession() session.evaluate(wlexpr(&#39;y[x_] := a x^2 + b x + c&#39;)) session.evaluate(wlexpr(&#39;p1 = {0.3, -0.02}&#39;)) session.evaluate(wlexpr(&#39;p2 = {1, 1}&#39;)) session.evaluate(wlexpr(&#39;sol1 = Solve[ {y[p1[[1]]] == p1[[2]], y[p2[[1]]] == p2[[2]]}, {a, b, c}][[1]]&#39;)) session.evaluate(wlexpr(&#39;sol2 = Solve[(D[(y[x] /. sol1), x] /. x -&gt; 0.3) == 0, a][[1]]&#39;)) par = list(session.evaluate(wlexpr(&#39;{a, b, c} /. sol1 /. sol2&#39;))) . Equations may not give solutions for all &#34;solve&#34; variables. Equations may not give solutions for all &#34;solve&#34; variables. . par . [2.0816326530612246, -1.2489795918367346, 0.16734693877551027] .",
            "url": "https://yairmau.com/jupyter/2020/01/01/websitelogo.html",
            "relUrl": "/jupyter/2020/01/01/websitelogo.html",
            "date": " • Jan 1, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "The time-dependent Ginzburg-Landau equation",
            "content": ". Introduction . Simulation of the Time-Dependent Ginzburg-Landau Equation $$ frac{ text{d}u}{ text{d}t}= u - u^3 +D nabla^2 u,$$ in 1 and 2 spatial dimensions. This is the simplest example of numerical integration through Finite Differences: . Euler method to advance time | Five-point stencil to compute the laplacian, periodic boundary conditions are assumed. See an example of the output here: https://www.youtube.com/watch?v=JgE9Px7zsQE | . Code . import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.axes_grid1 import make_axes_locatable import time as tm . # grid size n = 128 # for 1d simulation write N=(n,) N=(n,n) # diffusion coefficient D = 1.0 # spatial dimensions L = 100.0 dx = L / n x = np.arange(0,L,dx) # time t = 0.0 total_time = 3.0 # beware of the Von Neumann stability analysis # https://en.wikipedia.org/wiki/Von_Neumann_stability_analysis dt = 0.2 * 0.5 * dx**2 / D . define functions . def periodic_lap_1d(u,dx=1.0): return (+1*np.roll(u,+1) +1*np.roll(u,-1) -2*u) / dx**2 def periodic_lap_2d(u,dx=1.0): return (+1*np.roll(u,+1,axis=0) +1*np.roll(u,-1,axis=0) +1*np.roll(u,+1,axis=1) +1*np.roll(u,-1,axis=1) -4*u) / dx**2 f = lambda u: u - u**3 . initialize and start plotting . plt.ion() fig = plt.figure(1,figsize=(7,6)) plt.clf() ax = fig.add_subplot(111) # random initial condition u = 2*np.random.random(N)-1.0 if len(N) == 1: lap = periodic_lap_1d p, = ax.plot(x,u) ax.axis([x[0],x[-1],-1.1,1.1]) if len(N) == 2: lap = periodic_lap_2d p = ax.imshow(u,cmap=&quot;RdGy&quot;, vmin=-1.0, vmax=1.0,extent=[0,L,0,L]) # create an axes on the right side of ax. The width of cax will be 5% # of ax and the padding between cax and ax will be fixed at 0.15 inch. divider = make_axes_locatable(ax) colorbar_ax = divider.append_axes(&quot;right&quot;, size=&quot;5%&quot;, pad=0.15) cbar = fig.colorbar(p, cax=colorbar_ax, ticks=[-1,-0.5,0,0.5,1]) ax.set_title(&quot;time={:5.1f}&quot;.format(0.0)) . Text(0.5, 1.0, &#39;time= 0.0&#39;) . start simulation . while t&lt;total_time: t += dt u = u + dt * (f(u) + D * lap(u,dx) ) # we don&#39;t need to plot again, just to update the data of the plot if len(N) == 1: p.set_data(x,u) if len(N) == 2: p.set_data(u) ax.set_title(&quot;time={:5.1f}&quot;.format(t)) fig.canvas.draw() .",
            "url": "https://yairmau.com/jupyter/2020/01/01/tdgle.html",
            "relUrl": "/jupyter/2020/01/01/tdgle.html",
            "date": " • Jan 1, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Fancy subplot grid",
            "content": ". Introduction . With GridSpec you can create any combination of panels . The code . import numpy as np import matplotlib import matplotlib.pyplot as plt import matplotlib.gridspec as gridspec from matplotlib.ticker import FuncFormatter . # http://wiki.scipy.org/Cookbook/Matplotlib/LaTeX_Examples # this is a latex constant, don&#39;t change it. pts_per_inch = 72.27 # write &quot; the textwidth&quot; (or &quot; showthe columnwidth&quot; for a 2 collumn text) text_width_in_pts = 246.0 # inside a figure environment in latex, the result will be on the # dvi/pdf next to the figure. See url above. text_width_in_inches = text_width_in_pts / pts_per_inch # make rectangles with a nice proportion golden_ratio = 0.618 # figure.png or figure.eps will be intentionally larger, because it is prettier inverse_latex_scale = 2 # when compiling latex code, use # includegraphics[scale=(1/inverse_latex_scale)]{figure} # we want the figure to occupy 2/3 (for example) of the text width fig_proportion = (3.0 / 3.0) csize = inverse_latex_scale * fig_proportion * text_width_in_inches # always 1.0 on the first argument fig_size = (1.0 * csize, 1.1 * csize) # find out the fontsize of your latex text, and put it here text_size = inverse_latex_scale * 12 tick_size = inverse_latex_scale * 8 # learn how to configure: # http://matplotlib.sourceforge.net/users/customizing.html params = {&#39;backend&#39;: &#39;ps&#39;, &#39;axes.labelsize&#39;: text_size, &#39;legend.fontsize&#39;: tick_size, &#39;legend.handlelength&#39;: 2.5, &#39;legend.borderaxespad&#39;: 0, &#39;xtick.labelsize&#39;: tick_size, &#39;ytick.labelsize&#39;: tick_size, &#39;font.family&#39;: &#39;serif&#39;, &#39;font.size&#39;: text_size, # Times, Palatino, New Century Schoolbook, # Bookman, Computer Modern Roman &#39;font.serif&#39;: [&#39;Times&#39;], &#39;ps.usedistiller&#39;: &#39;xpdf&#39;, &#39;text.usetex&#39;: True, &#39;figure.figsize&#39;: fig_size, # include here any neede package for latex &#39;text.latex.preamble&#39;: [r&#39; usepackage{amsmath}&#39;, ], } plt.rcParams.update(params) plt.ioff() plt.clf() # figsize accepts only inches. fig = plt.figure(1, figsize=fig_size) gs = gridspec.GridSpec(3, 2, width_ratios=[1,0.5], height_ratios=[1,0.7,0.3]) gs.update(left=0.16, right=0.86,top=0.92, bottom=0.08, hspace=0.05, wspace=0.05) . subplot a . ax0 = plt.subplot(gs[0, :]) heaviside = lambda x: 0.5 * (np.sign(x) + 1) x = np.arange(0, 10.01, 0.01) ax0.plot(x, heaviside(x - 2), color=&#39;purple&#39;, lw=3) ax0.text(2.5, 1.1, r&quot;$ longleftarrow$ heaviside&quot;) # y ticks as a percentage ax0.set_yticks(np.arange(-0.5, 2.0, 0.5)) def to_percent(y, position): # Ignore the passed in position. This has the effect of scaling the default # tick locations. s = &quot;{:+.0f}&quot;.format(y * 100) # str(100 * y) # The percent symbol needs escaping in latex if matplotlib.rcParams[&#39;text.usetex&#39;] is True: return s + r&#39;$ %$&#39; else: return s + &#39;%&#39; # Create the formatter using the function to_percent. This multiplies all the # default labels by 100, making them all percentages formatter = FuncFormatter(to_percent) # Set the formatter ax0.yaxis.set_major_formatter(formatter) ax0.set_ylabel(&quot;heaviside, percentage&quot;) # x ticks on top ax0.axis([x.min(), x.max(), -0.5, 1.5]) ax0.xaxis.tick_top() ax0.set_xlabel(r&quot;x labels on top&quot;) ax0.xaxis.set_label_position(&quot;top&quot;) # transAxes makes position relative to axes ax0.text(0.97, 0.97, r&quot; textbf{a}&quot;, transform=ax0.transAxes, horizontalalignment=&#39;right&#39;, verticalalignment=&#39;top&#39;) # copy window with same x axis (y will be different) ax0b = ax0.twinx() ax0b.plot(x, np.tanh(x - 5), color=&quot;green&quot;, linewidth=3) ax0b.axis([x.min(), x.max(), -1.1, 2.5]) ax0b.text(5.5, 0, r&quot;tanh $ longrightarrow$&quot;) ax0b.set_ylabel(r&#39;tanh, offset label&#39;) ax0b.yaxis.set_label_coords(1.1, 0.70) . subplot b . ax10 = plt.subplot(gs[1, 0]) x = np.arange(-5, 5, 0.01) y = np.exp(-x) ax10.plot(x, y, color=&quot;orange&quot;, lw=3) ax10.set_yscale(&#39;log&#39;, basey=2) ax10.set_yticks(2.0 ** np.arange(-7, 7, 3)) ax10.text(1.0, 1, r&quot;$y=e^{-x}$&quot;) ax10.set_xticks(np.arange(-5, 6, 2)) ax10.set_xticklabels(np.arange(-5, 6, 2), y=0.15) ax10.get_yaxis().set_tick_params(direction=&#39;out&#39;) ax10.set_ylabel(&quot;log scale base 2&quot;, labelpad=15) ax10.text(0.97, 0.97, r&quot; textbf{b}&quot;, transform=ax10.transAxes, horizontalalignment=&#39;right&#39;, verticalalignment=&#39;top&#39;) . Text(0.97, 0.97, &#39; textbf{b}&#39;) . subplot c . ax11 = plt.subplot(gs[1, 1]) x = np.arange(1.0, np.e ** 4, 0.01) y = x ** (-0.8) ax11.plot(x, y, color=&quot;cyan&quot;, lw=3) ax11.text(2, 1, r&quot;$y=x^{-0.8}$&quot;, fontsize=tick_size) ax11.loglog(x, y, basex=np.e, basey=np.e) xt = np.exp(np.arange(1, 4, 1)) yt = np.pi ** (np.arange(-3, 2, 1)) ax11.set_xticks(xt) ax11.set_xticklabels(xt, y=0.15) ax11.set_yticks(yt) def ticks_e(y, pos): # base e return r&#39;$e^{:.0f}$&#39;.format(np.log(y)) def ticks_pi(y, pos): # base pi, why not? return r&#39;$ pi^{%+.0f}$&#39;%(np.log(y)/np.log(np.pi)) ax11.xaxis.set_major_formatter(FuncFormatter(ticks_e)) ax11.yaxis.set_major_formatter(FuncFormatter(ticks_pi)) ax11.yaxis.tick_right() ax11.yaxis.set_label_position(&quot;right&quot;) ax11.set_ylabel(&quot;right side&quot;, labelpad=10) ax11.text(0.97, 0.97, r&quot; textbf{c}&quot;, transform=ax11.transAxes, horizontalalignment=&#39;right&#39;, verticalalignment=&#39;top&#39;) . Text(0.97, 0.97, &#39; textbf{c}&#39;) . subplot d . ax20 = plt.subplot(gs[2, 0]) ax20.axis([0, 1, 0, 1]) ax20.set_xticks(np.arange(0, 1.1, 0.2)) ax20.set_xticklabels([&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;], rotation=30, horizontalalignment=&quot;right&quot;) ax20.set_yticks([]) ax20.text(0.97, 0.97, r&quot; textbf{d}&quot;, transform=ax20.transAxes, horizontalalignment=&#39;right&#39;, verticalalignment=&#39;top&#39;) . Text(0.97, 0.97, &#39; textbf{d}&#39;) . subplot e . ax21 = plt.subplot(gs[2, 1]) ax21.set_xticks([]) ax21.set_yticks([]) ax21.axis([0, 1, 0, 1]) ax21.text(0.97, 0.97, r&quot; textbf{e}&quot;, transform=ax21.transAxes, horizontalalignment=&#39;right&#39;, verticalalignment=&#39;top&#39;) . Text(0.97, 0.97, &#39; textbf{e}&#39;) . %matplotlib notebook fig.savefig(&quot;./python_figures/subplot-grid.png&quot;, dpi=300) fig .",
            "url": "https://yairmau.com/jupyter/2020/01/01/subplotgrid.html",
            "relUrl": "/jupyter/2020/01/01/subplotgrid.html",
            "date": " • Jan 1, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Streamplot",
            "content": ". Introduction . Streamplot of a two-dimensional linear system, with eigenvectors and nullclines. Python shows LaTeX equations beautifully. Main features: meshgrid, streamplot, contour, legend, LaTeX . The code . %matplotlib notebook import matplotlib import matplotlib.pyplot as plt import numpy as np . make graph look pretty . # http://wiki.scipy.org/Cookbook/Matplotlib/LaTeX_Examples # this is a latex constant, don&#39;t change it. pts_per_inch = 72.27 # write &quot; the textwidth&quot; (or &quot; showthe columnwidth&quot; for a 2 collumn text) text_width_in_pts = 300.0 # inside a figure environment in latex, the result will be on the # dvi/pdf next to the figure. See url above. text_width_in_inches = text_width_in_pts / pts_per_inch # make rectangles with a nice proportion golden_ratio = 0.618 # figure.png or figure.eps will be intentionally larger, because it is prettier inverse_latex_scale = 2 # when compiling latex code, use # includegraphics[scale=(1/inverse_latex_scale)]{figure} # we want the figure to occupy 2/3 (for example) of the text width fig_proportion = (3.0 / 3.0) csize = inverse_latex_scale * fig_proportion * text_width_in_inches # always 1.0 on the first argument fig_size = (1.0 * csize, 0.8 * csize) # find out the fontsize of your latex text, and put it here text_size = inverse_latex_scale * 12 tick_size = inverse_latex_scale * 8 # learn how to configure: # http://matplotlib.sourceforge.net/users/customizing.html params = {&#39;backend&#39;: &#39;ps&#39;, &#39;axes.labelsize&#39;: text_size, &#39;legend.fontsize&#39;: tick_size, &#39;legend.handlelength&#39;: 2.5, &#39;legend.borderaxespad&#39;: 0, &#39;xtick.labelsize&#39;: tick_size, &#39;ytick.labelsize&#39;: tick_size, &#39;font.family&#39;: &#39;serif&#39;, &#39;font.size&#39;: text_size, # Times, Palatino, New Century Schoolbook, # Bookman, Computer Modern Roman # &#39;font.serif&#39;: [&#39;Times&#39;], &#39;ps.usedistiller&#39;: &#39;xpdf&#39;, &#39;text.usetex&#39;: True, &#39;figure.figsize&#39;: fig_size, # include here any neede package for latex &#39;text.latex.preamble&#39;: [r&#39; usepackage{amsmath}&#39;, ], } plt.rcParams.update(params) plt.ioff() # figsize accepts only inches. fig = plt.figure(1, figsize=fig_size) fig.subplots_adjust(left=0.10, right=0.97, top=0.82, bottom=0.10, hspace=0.02, wspace=0.02) ax = fig.add_subplot(111) . define parameters, system of equations, and equation for eigenvectors . # parameters as a dictionary p = {&#39;a&#39;: -1.0, &#39;b&#39;: +0.2, &#39;c&#39;: +1.2, &#39;d&#39;: -1.5} # the equations def system_equations(x,y): return [p[&#39;a&#39;] * x + p[&#39;b&#39;] * y, p[&#39;c&#39;] * x + p[&#39;d&#39;] * y, ] # eigenvectors eigen_vec = 100 * np.array([ [(p[&#39;a&#39;] - p[&#39;d&#39;] - np.sqrt((p[&#39;a&#39;] - p[&#39;d&#39;]) ** 2 + 4.0 * p[&#39;b&#39;] * p[&#39;c&#39;])) / (2.0 * p[&#39;c&#39;]), 1.0], [(p[&#39;a&#39;] - p[&#39;d&#39;] + np.sqrt((p[&#39;a&#39;] - p[&#39;d&#39;]) ** 2 + 4.0 * p[&#39;b&#39;] * p[&#39;c&#39;])) / (2.0 * p[&#39;c&#39;]), 1.0], ]) . there are two equivalent ways to build a mesh, choose the one that makes more sense to you... . min_x, max_x = [-1, 1] min_y, max_y = [-4, 4] divJ = 50j div = 50 # 1st way # Y, X = np.mgrid[min_y:max_y:div,min_x:max_x:div] # 2nd way X, Y = np.meshgrid(np.linspace(min_x, max_x, div), np.linspace(min_y, max_y, div)) # streamplot density = 2 * [0.80] minlength = 0.2 arrow_color = 3 * [0.5] ax.streamplot(X, Y, system_equations(X, Y)[0], system_equations(X, Y)[1], density=density, color=arrow_color, arrowsize=2, linewidth=2, minlength=minlength) . &lt;matplotlib.streamplot.StreamplotSet at 0x7ff7c5afdd50&gt; . nullclines . null_0 = ax.contour(X, Y, system_equations(X, Y)[0], levels=[0], colors=&#39;black&#39;, linewidths=3) null_1 = ax.contour(X, Y,system_equations(X, Y)[1], levels=[0], colors=&#39;blue&#39;, linewidths=3) n0 = null_0.collections[0] n1 = null_1.collections[0] . eigenvectors . eigen_0, = ax.plot([eigen_vec[0, 0],-eigen_vec[0, 0]], [eigen_vec[0, 1],-eigen_vec[0, 1]], color=&#39;red&#39;, lw=2, ls=&quot;--&quot;) eigen_1, = ax.plot([eigen_vec[1, 0],-eigen_vec[1, 0]], [eigen_vec[1, 1],-eigen_vec[1, 1]], color=&#39;orange&#39;, lw=2, ls=&quot;--&quot;) dash = (15, 10, 15, 10) eigen_0.set_dashes(dash) eigen_1.set_dashes(dash) . some labels, legend, and text . ax.set_ylabel(r&quot;$y$&quot;, rotation=&#39;horizontal&#39;) ax.set_xlabel(r&quot;$x$&quot;, labelpad=5) ax.legend([n0, n1, eigen_0, eigen_1], [r&#39;$dx/dt=0$&#39;, r&#39;$dy/dt=0$&#39;, &quot;eigenvector 1&quot;, &quot;eigenvector 2&quot;], loc=&quot;lower right&quot;, frameon=True, fancybox=False, shadow=False, ncol=2, borderpad=0.5, labelspacing=0.5, handlelength=3, handletextpad=0.1, borderaxespad=0.3, columnspacing=2) ax.text(-1.0, 4.3, (r&quot;$ frac{d}{dt} begin{pmatrix}x y end{pmatrix}=$&quot; r&quot;$ begin{pmatrix}a&amp;b c&amp;d end{pmatrix} cdot$&quot; r&quot;$ begin{pmatrix}x y end{pmatrix}$&quot;)) ax.text(0.1, 5.0, r&quot;$a={:.1f} qquad b={:.1f}$ &quot;.format(p[&#39;a&#39;], p[&#39;b&#39;])) ax.text(0.1, 4.3, r&quot;$c={:.1f} qquad d={:.1f}$ &quot;.format(p[&#39;c&#39;], p[&#39;d&#39;])) ax.axis([min_x, max_x, min_y, max_y]) fig.savefig(&quot;python_figures/streamplot.png&quot;, resolution=300) plt.draw() fig .",
            "url": "https://yairmau.com/jupyter/2020/01/01/streamplot.html",
            "relUrl": "/jupyter/2020/01/01/streamplot.html",
            "date": " • Jan 1, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Least Squares",
            "content": ". Introduction . This code produces the figure above. It&#39;s main tool is the curve_fit method, that allows us to fit any function to data, and get optimal parameter values. . The code . %matplotlib notebook import matplotlib.pyplot as plt import numpy as np import matplotlib.gridspec as gridspec import scipy.special from scipy.optimize import curve_fit import matplotlib.patches as patches . Make graph look pretty . %%capture out %matplotlib notebook # http://wiki.scipy.org/Cookbook/Matplotlib/LaTeX_Examples # this is a latex constant, don&#39;t change it. pts_per_inch = 72.27 # write &quot; the textwidth&quot; (or &quot; showthe columnwidth&quot; for a 2 collumn text) text_width_in_pts = 300.0 # inside a figure environment in latex, the result will be on the # dvi/pdf next to the figure. See url above. text_width_in_inches = text_width_in_pts / pts_per_inch # make rectangles with a nice proportion golden_ratio = 0.618 # figure.png or figure.eps will be intentionally larger, because it is prettier inverse_latex_scale = 2 # when compiling latex code, use # includegraphics[scale=(1/inverse_latex_scale)]{figure} # we want the figure to occupy 2/3 (for example) of the text width fig_proportion = (3.0 / 3.0) csize = inverse_latex_scale * fig_proportion * text_width_in_inches # always 1.0 on the first argument fig_size = (1.0 * csize, 0.85 * csize) # find out the fontsize of your latex text, and put it here text_size = inverse_latex_scale * 12 label_size = inverse_latex_scale * 10 tick_size = inverse_latex_scale * 8 # learn how to configure: # http://matplotlib.sourceforge.net/users/customizing.html params = {#&#39;backend&#39;: &#39;ps&#39;, &#39;axes.labelsize&#39;: 16, &#39;legend.fontsize&#39;: tick_size, &#39;legend.handlelength&#39;: 2.5, &#39;legend.borderaxespad&#39;: 0, &#39;axes.labelsize&#39;: label_size, &#39;xtick.labelsize&#39;: tick_size, &#39;ytick.labelsize&#39;: tick_size, &#39;font.family&#39;: &#39;serif&#39;, &#39;font.size&#39;: text_size, # &#39;font.serif&#39;: [&#39;Computer Modern Roman&#39;], &#39;ps.usedistiller&#39;: &#39;xpdf&#39;, &#39;text.usetex&#39;: True, &#39;figure.figsize&#39;: fig_size, # include here any neede package for latex &#39;text.latex.preamble&#39;: [r&#39; usepackage{amsmath}&#39;], } plt.rcParams.update(params) plt.clf() fig = plt.figure(1, figsize=fig_size) # figsize accepts only inches. fig.subplots_adjust(left=0.04, right=0.98, top=0.93, bottom=0.15, hspace=0.05, wspace=0.02) plt.ioff() . Configure axes and some function definitions . x = np.arange(0, 12, 0.4) ax1 = fig.add_subplot(211, aspect=&#39;equal&#39;) ax2 = fig.add_subplot(212, aspect=&#39;equal&#39;) ax1.set_xlim((x.min(), x.max())) ax2.set_xlim((x.min(), x.max())) ax1.set_ylim(-1, 3.5) ax2.set_ylim(-1, 3.5) ax1.set_xticklabels([]) ax1.set_yticks(np.arange(-1, 4)) ax2.set_yticks(np.arange(-1, 4)) def func(x, par0, par1, par2): return par0 + np.cos(par1 * x + par2) def add_rec(ax, c, v, col): ax.add_patch( patches.Rectangle( c, # (x,y) np.abs(v), # width v, # height alpha=0.4, color=col ) ) . Now let&#39;s plot some stuff . %matplotlib notebook # the parameter values par = (1, 2, 1) # generating data with noise y = func(x, *par) + (np.random.random(len(x)) - 0.5) ax1.plot(x, y, marker=&#39;o&#39;, ls=&#39;None&#39;, markerfacecolor=&quot;blue&quot;, markeredgecolor=&quot;black&quot;) ax2.plot(x, y, marker=&#39;o&#39;, ls=&#39;None&#39;, markerfacecolor=&quot;red&quot;, markeredgecolor=&quot;black&quot;) # best fit popt, pcov = curve_fit(func, x, y, p0=(1.5, 1.5, 2.5)) # p0 = initial guess p0, p1, p2 = popt # The total sum of squares (proportional to the variance of the data) SStot = ((y - y.mean()) ** 2).sum() # The sum of squares of residuals SSres = ((y - func(x, p0, p1, p2)) ** 2).sum() Rsquared = 1 - SSres / SStot # plot best fit h = np.linspace(x.min(), x.max(), 1001) fit, = ax1.plot(h, func(h, p0, p1, p2), color=&#39;black&#39;, linewidth=2) ax1.legend([fit], [&quot;Best fit&quot;], loc=&quot;upper right&quot;, frameon=False, handlelength=4) # plot mean mean, = ax2.plot(h, h * 0 + np.mean(y), ls=&#39;--&#39;, color=&#39;black&#39;, linewidth=2) ax2.legend([mean], [&quot;Mean&quot;], loc=&quot;upper right&quot;, frameon=False, handlelength=4) # plot blue and red squares for ind in np.arange(len(x)): x0 = x[ind] y0 = y[ind] # print(x0,y0) v1 = y0 - func(x0, p0, p1, p2) v2 = y0 - y.mean() add_rec(ax1, (x0, y0), -v1, &quot;blue&quot;) add_rec(ax2, (x0, y0), -v2, &quot;red&quot;) ax2.text(0.5, 2.7, r&quot;Total sum of squares: {:.1f}&quot;.format(SStot)) ax1.text(0.5, 2.7, r&quot;Sum of squares of residuals: {:.1f}&quot;.format(SSres)) ax2.set_xlabel( r&quot;R-squared = $1 - displaystyle frac{ text{blue area}}{ text{red area}}$ = &quot; + &quot;{:.2f}&quot;.format(Rsquared)) ax1.set_xlabel( r&quot;Data: $f(x) = p_0 + cos(p_1 x + p_2)+ $ noise &quot;) ax1.xaxis.set_label_position(&quot;top&quot;) fig.savefig(&quot;./python_figures/least-squares.png&quot;,dpi=300) fig .",
            "url": "https://yairmau.com/jupyter/2020/01/01/leastsquares.html",
            "relUrl": "/jupyter/2020/01/01/leastsquares.html",
            "date": " • Jan 1, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "A hysteresis mechanism",
            "content": ". Introduction . Hysteresis mechanism created by bistability of states. . Energy function: $$f = u^4 - 2u^2 + hu$$ . The code . # comment these lines if you want interactive mode, # i.e., if you want to see the animation in real time. import matplotlib matplotlib.use(&#39;Agg&#39;) . import matplotlib.pyplot as plt import numpy as np import os import sympy from scipy.integrate import ode # learn how to configure: http://matplotlib.sourceforge.net/users/customizing.html params = {#&#39;backend&#39;: &#39;GTKAgg&#39;, &#39;legend.handlelength&#39;: 2.5, &#39;legend.borderaxespad&#39;: 0, &#39;font.family&#39;:&#39;serif&#39;, &#39;font.size&#39;: 18, &#39;font.serif&#39;:[&#39;Times&#39;], # Times, Palatino, New Century Schoolbook, Bookman, Computer Modern Roman &#39;ps.usedistiller&#39;: &#39;xpdf&#39;, &#39;text.usetex&#39;: True, } plt.rcParams.update(params) fig=plt.figure(1,figsize=(9.6,5.4),dpi=100) # 1920x1080 # figsize accepts only inches. if you rather think in cm, change the code yourself. fig.clf() fig.subplots_adjust(left=0.07, right=0.93,top=0.90, bottom=0.12,hspace=0.02,wspace=0.10) Hlim=2.5 # parameter range from -Hlim to Hlim ax1=fig.add_subplot(121) ax1.set_xticks([]) ax1.set_yticks([]) ax1.set_xlabel(r&#39;System response&#39;,labelpad=12) ax1.set_ylabel(&#39;Energy&#39;,labelpad=12) ax1.axis([-Hlim,Hlim,-5,5]) ax2=fig.add_subplot(122) ax2.set_xticks([]) ax2.set_yticks([]) ax2.set_xlabel(r&#39;Parameter&#39;,labelpad=12) ax2.set_ylabel(r&#39;System response&#39;,labelpad=12) ax2.yaxis.set_label_position(&quot;right&quot;) ax2.axis([-Hlim*1.2,Hlim*1.2,-2,2]) frame_names = [] frame_index = 0 make_movie=True plt.ion() . # energy function and its derivative f = lambda u,h: u**4-2*u**2+h*u fprime = lambda u,h: sympy.diff(f(u,h),u) Hinit=Hlim ulim=2.5 # system response axis, from -ulim to ulim u = np.linspace(-ulim,ulim,101) x = sympy.Symbol(&#39;x&#39;) def res(h): &quot;&quot;&quot;System response is one of the real roots of the energy function derivative &quot;&quot;&quot; # derivative roots, complex resp = sympy.solvers.solve(fprime(x,h),x) # numerical evaluation resp = map(sympy.N,resp) # let&#39;s check which roots are real isreal = len(resp)*[False] for i in range(len(resp)): # negligible imaginary component if np.abs(sympy.functions.im(resp[i]))&lt;1e-15: resp[i]=sympy.functions.re(resp[i]) isreal[i]=True resp = np.array(resp) # return only real roots return resp[np.array(isreal)] # let&#39;s plot stuff, and make a nice movie #### left plot, ax1 #### line_func, = ax1.plot(u,f(u,Hinit),lw=2,color=&#39;black&#39;) # ball color ball_color = &quot;blue&quot; # minimum = the smallest root, the leftmost root mini = np.min(res(Hinit)) # calculated for initial parameter value boost = 0.22 # so that ball sits on top of the curve # plot ball ball_u, = ax1.plot([mini],[f(mini,Hinit)+boost],&#39;o&#39;, markersize=12, markerfacecolor=ball_color) #### right plot, ax2 #### # build empty hysteresis array, we will add values # as simulation progresses deetype = np.dtype([(&#39;h&#39;, &#39;float64&#39;), (&#39;u&#39;, &#39;float64&#39;)]) hysteresis = np.array([(Hinit,mini)],dtype=deetype) line_hyst, = ax2.plot(hysteresis[&#39;h&#39;],hysteresis[&#39;u&#39;], lw=2,color=&#39;black&#39;) ballH, = ax2.plot([hysteresis[&#39;h&#39;][-1]],[hysteresis[&#39;u&#39;][-1]],&#39;o&#39;, markersize=12, markerfacecolor=ball_color) plt.show() . # time to simulate Total_time = 15 # seconds fps = 24 # frames per second # divided by 2 because we ramp down then up param_vec = np.linspace(Hlim,-Hlim,Total_time*fps/2) # ramp down for H in param_vec: line_func.set_data(u,f(u,H)) # update line on the left mini = np.min(res(H)) # calculate new minimum ball_u.set_data([mini],[f(mini,H)+boost]) # update ball on the left new_line = np.array([(H,mini)],dtype=deetype) # create new line # append new line to hysteresis array hysteresis = np.concatenate((hysteresis,new_line)) line_hyst.set_data(hysteresis[&#39;h&#39;],hysteresis[&#39;u&#39;]) # update line ballH.set_data([hysteresis[&#39;h&#39;][-1]],[hysteresis[&#39;u&#39;][-1]]) # update ball on the right fig.canvas.draw() if make_movie: fname = &quot;_tmp{:05d}.png&quot;.format(frame_index) frame_names.append(fname) fig.savefig(fname,dpi=200) frame_index+=1 # ramp up for H in param_vec[::-1]: # just reverse parameter array line_func.set_data(u,f(u,H)) maxi = np.max(res(H)) # everything is the same, but now with maximum ball_u.set_data([maxi],[f(maxi,H)+boost]) new_line = np.array([(H,maxi)],dtype=deetype) hysteresis = np.concatenate((hysteresis,new_line)) line_hyst.set_data(hysteresis[&#39;h&#39;],hysteresis[&#39;u&#39;]) ballH.set_data([hysteresis[&#39;h&#39;][-1]],[hysteresis[&#39;u&#39;][-1]]) fig.canvas.draw() if make_movie: fname = &quot;_tmp{:05d}.png&quot;.format(frame_index) frame_names.append(fname) fig.savefig(fname,dpi=200) frame_index+=1 if make_movie: frames = &quot;_tmp%5d.png&quot; movie_command = &quot;ffmpeg -y -r {:} -i {:} ball.mp4&quot;.format(fps,frames) os.system(movie_command) for fname in frame_names: # pass os.remove(fname) .",
            "url": "https://yairmau.com/jupyter/2020/01/01/hysteresis.html",
            "relUrl": "/jupyter/2020/01/01/hysteresis.html",
            "date": " • Jan 1, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Fun with histograms",
            "content": ". Introduction . This code produces the figure above. I tried to showcase a few things one can do with 1d and 2d histograms. . The code . import matplotlib.pyplot as plt import numpy as np import matplotlib.gridspec as gridspec import scipy.special from scipy.optimize import curve_fit . make graph look pretty . # http://wiki.scipy.org/Cookbook/Matplotlib/LaTeX_Examples # this is a latex constant, don&#39;t change it. pts_per_inch = 72.27 # write &quot; the textwidth&quot; (or &quot; showthe columnwidth&quot; for a 2 collumn text) text_width_in_pts = 450.0 # inside a figure environment in latex, the result will be on the # dvi/pdf next to the figure. See url above. text_width_in_inches = text_width_in_pts / pts_per_inch # make rectangles with a nice proportion golden_ratio = 0.618 # figure.png or figure.eps will be intentionally larger, because it is prettier inverse_latex_scale = 2 # when compiling latex code, use # includegraphics[scale=(1/inverse_latex_scale)]{figure} # we want the figure to occupy 2/3 (for example) of the text width fig_proportion = (3.0 / 3.0) csize = inverse_latex_scale * fig_proportion * text_width_in_inches # always 1.0 on the first argument fig_size = (1.0 * csize, 0.5 * csize) # find out the fontsize of your latex text, and put it here text_size = inverse_latex_scale * 12 label_size = inverse_latex_scale * 10 tick_size = inverse_latex_scale * 8 # learn how to configure: # http://matplotlib.sourceforge.net/users/customizing.html params = {&#39;backend&#39;: &#39;ps&#39;, &#39;axes.labelsize&#39;: 16, &#39;legend.fontsize&#39;: tick_size, &#39;legend.handlelength&#39;: 2.5, &#39;legend.borderaxespad&#39;: 0, &#39;axes.labelsize&#39;: label_size, &#39;xtick.labelsize&#39;: tick_size, &#39;ytick.labelsize&#39;: tick_size, &#39;font.family&#39;: &#39;serif&#39;, &#39;font.size&#39;: text_size, # &#39;font.serif&#39;: [&#39;Computer Modern Roman&#39;], &#39;ps.usedistiller&#39;: &#39;xpdf&#39;, &#39;text.usetex&#39;: True, &#39;figure.figsize&#39;: fig_size, } plt.rcParams.update(params) plt.ioff() fig = plt.figure(1, figsize=fig_size) # figsize accepts only inches. . Panels on the left of the figure . gs = gridspec.GridSpec(2, 2, width_ratios=[1, 0.2], height_ratios=[0.2, 1]) gs.update(left=0.05, right=0.50, top=0.95, bottom=0.10, hspace=0.02, wspace=0.02) sigma = 1.0 # standard deviation (spread) mu = 0.0 # mean (center) of the distribution x = np.random.normal(loc=mu, scale=sigma, size=5000) k = 2.0 # shape theta = 1.0 # scale y = np.random.gamma(shape=k, scale=theta, size=5000) # bottom left panel ax10 = plt.subplot(gs[1, 0]) counts, xedges, yedges, image = ax10.hist2d(x, y, bins=40, cmap=&quot;YlOrRd&quot;, density=True) dx = xedges[1] - xedges[0] dy = yedges[1] - yedges[0] xvec = xedges[:-1] + dx / 2 yvec = yedges[:-1] + dy / 2 ax10.set_xlabel(r&quot;$x$&quot;) ax10.set_ylabel(r&quot;$y$&quot;, rotation=&quot;horizontal&quot;) ax10.text(-2, 8, r&quot;$p(x,y)$&quot;) ax10.set_xlim([xedges.min(), xedges.max()]) ax10.set_ylim([yedges.min(), yedges.max()]) # top left panel ax00 = plt.subplot(gs[0, 0]) gaussian = (1.0 / np.sqrt(2.0 * np.pi * sigma ** 2)) * np.exp(-((xvec - mu) ** 2) / (2.0 * sigma ** 2)) xdist = counts.sum(axis=1) * dy ax00.bar(xvec, xdist, width=dx, fill=False, edgecolor=&#39;black&#39;, alpha=0.8) ax00.plot(xvec, gaussian, color=&#39;black&#39;) ax00.set_xlim([xedges.min(), xedges.max()]) ax00.set_xticklabels([]) ax00.set_yticks([]) ax00.set_xlabel(&quot;Normal distribution&quot;, fontsize=16) ax00.xaxis.set_label_position(&quot;top&quot;) ax00.set_ylabel(r&quot;$p(x)$&quot;, rotation=&quot;horizontal&quot;, labelpad=20) # bottom right panel ax11 = plt.subplot(gs[1, 1]) gamma_dist = yvec ** (k - 1.0) * np.exp(-yvec / theta) / (theta ** k * scipy.special.gamma(k)) ydist = counts.sum(axis=0) * dx ax11.barh(yvec, ydist, height=dy, fill=False, edgecolor=&#39;black&#39;, alpha=0.8) ax11.plot(gamma_dist, yvec, color=&#39;black&#39;) ax11.set_ylim([yedges.min(), yedges.max()]) ax11.set_xticks([]) ax11.set_yticklabels([]) ax11.set_ylabel(&quot;Gamma distribution&quot;, fontsize=16) ax11.yaxis.set_label_position(&quot;right&quot;) ax11.set_xlabel(r&quot;$p(y)$&quot;) ax11.xaxis.set_label_position(&quot;top&quot;) . Panels on the right of the figure . gs2 = gridspec.GridSpec(2, 1, width_ratios=[1], height_ratios=[1, 1]) gs2.update(left=0.60, right=0.98, top=0.95, bottom=0.10, hspace=0.02, wspace=0.05) x = np.random.normal(loc=0, scale=1, size=1000) y = np.random.gamma(shape=2, size=1000) bx10 = plt.subplot(gs2[1, 0]) bx00 = plt.subplot(gs2[0, 0]) N = 100 a = np.random.gamma(shape=5, size=N) my_bins = np.arange(0,15,1.5) n1, bins1, patches1 = bx00.hist(a, bins=my_bins, density=True, histtype=&#39;stepfilled&#39;, alpha=0.2, hatch=&#39;/&#39;) bx00.set_xlim([0, 15]) bx00.set_ylim([0, 0.28]) bx00.set_xticklabels([]) bx00.set_xlabel(r&quot; texttt{plt.hist}&quot;) bx00.xaxis.set_label_position(&quot;top&quot;) # the following way is equivalent to plt.hist, but it gives # the user more flexibility when plotting and analysing the results n2, bins2 = np.histogram(a, bins=my_bins, density=True) wid = bins2[1] - bins2[0] red, = bx10.plot(bins2[:-1]+wid/2, n2, marker=&#39;o&#39;, color=&#39;red&#39;) bx10.bar(bins2[:-1], n2, width=wid, fill=False, edgecolor=&#39;black&#39;, linewidth=3, alpha=0.8, align=&quot;edge&quot;) bx10.set_xlim([0, 15]) bx10.set_ylim([0, 0.28]) bx10.set_xlabel(r&quot; texttt{np.histogram}; quad texttt{plt.bar}&quot;) . Text(0.5, 0, &#39; texttt{np.histogram}; quad texttt{plt.bar}&#39;) . best fit . xdata = my_bins[:-1] + wid/2 ydata = n2 def func(x, p1, p2): return x ** (p1 - 1.0) * np.exp(-x / p2) / (p2 ** p1 * scipy.special.gamma(p1)) popt, pcov = curve_fit(func, xdata, ydata, p0=(1.5, 1.5)) # p0 = initial guess p1, p2 = popt SStot = ((ydata - ydata.mean()) ** 2).sum() SSres = ((ydata - func(xdata, p1, p2)) ** 1).sum() Rsquared = 1 - SSres / SStot h = np.linspace(0,15,101) bx00.plot(h, func(h, p1, p2), color=&#39;blue&#39;, linewidth=2) # dummy plot, just so we can have a legend on the bottom panel blue, = ax10.plot([100],[100], color=&#39;blue&#39;, linewidth=2, label=&quot;Best fit&quot;) bx10.legend([red,blue],[r&#39;Data&#39;,r&#39;Best fit, $r^2=${:.2f}&#39;.format(Rsquared)], loc=&#39;upper right&#39;, frameon=False, handlelength=4, markerfirst=False, numpoints=3) . /Users/yairmau/opt/anaconda3/lib/python3.7/site-packages/ipykernel_launcher.py:4: RuntimeWarning: invalid value encountered in double_scalars after removing the cwd from sys.path. . &lt;matplotlib.legend.Legend at 0x7fde860d7ed0&gt; . fig.savefig(&quot;./python_figures/histograms.png&quot;,dpi=300) fig .",
            "url": "https://yairmau.com/jupyter/2020/01/01/histograms.html",
            "relUrl": "/jupyter/2020/01/01/histograms.html",
            "date": " • Jan 1, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "Hilbert Curve",
            "content": ". Introduction . The Hilbert curve is calculated iteratively. Check out this: Hilbert_curve: Representation_as_Lindenmayer_system . The code . # comment this to enable interactive mode import matplotlib matplotlib.use(&#39;AGG&#39;) . import numpy as np import matplotlib.pyplot as plt import os . def apply_rules(s): &quot;&quot;&quot; Hilbert Curve as a Lindenmayer system (L-system) https://en.wikipedia.org/wiki/Hilbert_curve#Representation_as_Lindenmayer_system&quot;&quot;&quot; s=s.replace(&quot;a&quot;,&quot;-Bf+AfA+fB-&quot;) # capital letters &quot;A&quot; and &quot;B&quot; so that the second operation s=s.replace(&quot;b&quot;,&quot;+Af-BfB-fA+&quot;) # doesn&#39;t apply to the changes already made return s.lower() # make everyone lowercase axiom = &quot;a&quot; n=3 # number of iterations # displacements, ordered in a counter-clockwise direction dxdy = np.array([[ 1, 0], # right [ 0, 1], # up [-1, 0], # left [ 0,-1] ]) # down # displacement is of size 1, so the higher n is, the greater the domain length = 2**n-1; margin = 0.05*length domain = [0-margin,length+margin,0-margin,length+margin] # a 5% margin around the curve s = axiom # string to iterate upon for i in np.arange(n): s = apply_rules(s) . make_movie=True plt.ion() # interactive mode disabled if &quot;matplotlib.use(&#39;AGG&#39;)&quot; fig = plt.figure(figsize=(6,6)) ax = fig.add_subplot(111) ax.axis(&#39;off&#39;) # no frame ax.axis(domain) # domain size ax.set_aspect(&#39;equal&#39;) # square look ax.set_xticks([]); ax.set_yticks([]) # no ticks ax.set_title(r&quot;$n = {:d}$&quot;.format(n)) plt.show() # &quot;a&quot; and &quot;b&quot; can be erased now s=s.replace(&quot;a&quot;,&quot;&quot;) s=s.replace(&quot;b&quot;,&quot;&quot;) frame_names = [] # these two are only relevant if make_movie==True frame_counter=0 p = np.array([[0.0,0.0]]) # this is the starting point (0,0) p_plot, = plt.plot(p[:,0],p[:,1],color=&quot;black&quot;) # iterate on the string s for i,c in enumerate(s): # uncomment to see how fast things are going # print(&quot;{:d}/{:d}&quot;.format(i,len(s))) # rotations &quot;+&quot; and &quot;-&quot; change the displacement array dxdy # &quot;+&quot; means clockwise rotation if c == &#39;+&#39;: dxdy = np.roll(dxdy,+1,axis=0) # &quot;-&quot; means counter-clockwise rotation if c == &#39;-&#39;: dxdy = np.roll(dxdy,-1,axis=0) # forward &quot;f&quot; if c == &#39;f&#39;: # add one more point to array p p = np.vstack([p, [p[-1,0]+dxdy[0,0],p[-1,1]+dxdy[0,1]] ]) # update p_plot data, this is MUCH faster that plotting # several line segments separately p_plot.set_data(p[:,0],p[:,1]) fig.canvas.draw() if make_movie: fname = &quot;_tmp{:05d}.png&quot;.format(frame_counter) frame_names.append(fname) fig.savefig(fname,bbox_inches=&#39;tight&#39;,resolution=300) frame_counter += 1 . if make_movie: frames = &quot;_tmp%5d.png&quot; # movie_command = &quot;mencoder mf://*.png -mf fps=24:type=png --ovc lavc -lavcopts vcodec=mpeg4:mbd=2:trell -oac copy -o hil{:d}.avi&quot;.format(n) # we might have other .png figures in the directory # in this case, use the code below f = open(&quot;png_list.txt&quot;, &quot;w&quot;) for i in frame_names: f.write(i+&quot; n&quot;) f.close() movie_command = &quot;mencoder mf://@png_list.txt -mf fps=24:type=png -ovc lavc -lavcopts vcodec=mpeg4:mbd=2:trell -oac copy -o hil{:d}.avi&quot;.format(n) err=os.system(movie_command) if err!=0: raise RuntimeError(&quot;Couldn&#39;t run mencoder. Data in tmp*.png files&quot;) for fname in frame_names: os.remove(fname) # we now have one video ready. # if you want to join several videos, use this: # sudo apt-get install gpac # MP4Box -cat part1.avi -cat part2.avi -new joinedfile.avi .",
            "url": "https://yairmau.com/jupyter/2020/01/01/hilbertcurve.html",
            "relUrl": "/jupyter/2020/01/01/hilbertcurve.html",
            "date": " • Jan 1, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "Conway's Game of Life",
            "content": ". Introduction . This is a (slightly) modified version of Glowing Python&#39;s code. I make it available here because it features a few nice things: . how to make a movie using matplotlib.animation | how to write a generator (function with yield) | how to plot a sparce array (spy) | . The code . import numpy as np from matplotlib import pyplot as plt import matplotlib.animation as manimation def life(X, steps): &quot;&quot;&quot; Conway&#39;s Game of Life. - X, matrix with the initial state of the game. - steps, number of generations. &quot;&quot;&quot; def roll_it(x, y): # rolls the matrix X in a given direction # x=1, y=0 left; x=-1, y=0 right; return np.roll(np.roll(X, y, axis=0), x, axis=1) for _ in range(steps): # count the number of neighbours # the universe is considered toroidal Y = roll_it(1, 0) + roll_it(0, 1) + roll_it(-1, 0) + roll_it(0, -1) + roll_it(1, 1) + roll_it(-1, -1) + roll_it(1, -1) + roll_it(-1, 1) # game of life rules X = np.logical_or(np.logical_and(X, Y == 2), Y == 3) X = X.astype(int) yield X . dimensions = (90, 160) # height, width X = np.zeros(dimensions) # Y by X dead cells middle_y = dimensions[0] / 2 middle_x = dimensions[1] / 2 N_iterations = 600 # acorn initial condition # http://www.conwaylife.com/w/index.php?title=Acorn X[middle_y, middle_x:middle_x+2] = 1 X[middle_y, middle_x+4:middle_x+7] = 1 X[middle_y+1, middle_x+3] = 1 X[middle_y+2, middle_x+1] = 1 . FFMpegWriter = manimation.writers[&#39;ffmpeg&#39;] metadata = dict(title=&#39;Game of life&#39;, artist=&#39;Acorn initial condition&#39;) writer = FFMpegWriter(fps=10, metadata=metadata) fig = plt.figure() fig.patch.set_facecolor(&#39;black&#39;) with writer.saving(fig, &quot;game_of_life.mp4&quot;, 300): # last argument: dpi plt.spy(X, origin=&#39;lower&#39;) plt.axis(&#39;off&#39;) writer.grab_frame() plt.clf() for i, x in enumerate(life(X, N_iterations)): plt.title(&quot;iteration: {:03d}&quot;.format(i + 1)) plt.spy(x, origin=&#39;lower&#39;) plt.axis(&#39;off&#39;) writer.grab_frame() plt.clf() .",
            "url": "https://yairmau.com/jupyter/2020/01/01/gol.html",
            "relUrl": "/jupyter/2020/01/01/gol.html",
            "date": " • Jan 1, 2020"
        }
        
    
  
    
        ,"post12": {
            "title": "Fitzhugh-Nagumo Equation",
            "content": "https://youtu.be/5au-G5FuI_A . Introduction . We simulate the Fitzhugh-Nagumo equations $$ u_t = u - u^3 - v + nabla^2 u v_t = epsilon(u - a_1 v - a_0) + delta nabla^2 v, $$ using the semi-spectral time integration method. . This simultation was heavily inspired by Aric Hagberg&#39;s simulation in &quot;From Labyrinthine Patterns to Spiral Turbulence&quot;, PRL 1994. . The code below provides 3 initial conditions, &quot;squiggle, blocks, and random&quot;. For time integration, besides the spectral method, we also provide the Euler method. Details about the semi-spectral method can be found after the code. . Parameters: $ epsilon=0.3$, $ delta=2.0$, $a_1=1.4$, and $a_0=0$. . Other simulations and Python examples can be found on my website: yairmau.com. . The code . import packages . import numpy as np import matplotlib.pyplot as plt import os from matplotlib import rcParams rcParams[&#39;font.family&#39;] = &#39;monospace&#39; . define class with all the methods . class FitzHughNagumo(object): def __init__(self, epsilon=0.3, delta=2.0, a1=1.4, a0=0.0, n=(256, 256), l=(400, 400), start=0.0, step=1.0, finish=2000.0, dt=0.1, integration_type=&quot;spectral&quot;): self.epsilon = epsilon self.delta = delta self.a1 = a1 self.a0 = a0 self.n = n self.l = l self.start = start self.step = step self.finish = finish self.dt = dt self.integration_type = integration_type self.rhs_a = np.zeros((2, self.n[0], self.n[1])) def spectral_multiplier(self): dx = float(self.l[0]) / self.n[0] dy = float(self.l[1]) / self.n[1] # wave numbers fx = 2.0 * np.pi * np.fft.fftfreq(self.n[0], dx) fy = 2.0 * np.pi * np.fft.fftfreq(self.n[1], dy) kx = np.outer(fx, np.ones(self.n[0])) ky = np.outer(np.ones(self.n[1]), fy) # multiplier mult_a = np.zeros((2, self.n[0], self.n[1])) mult_a[0] = np.exp(-(kx ** 2 + ky ** 2) * self.dt) # u mult_a[1] = np.exp(-self.delta * (kx ** 2 + ky ** 2) * self.dt) # v return mult_a def rhs_reaction(self, a): u = a[0] # alias v = a[1] # alias # FHN right hand side self.rhs_a[0] = u - u ** 3 - v self.rhs_a[1] = self.epsilon * (u - self.a1 * v - self.a0) return self.rhs_a def rhs_euler(self, a): # boundary conditions in laplacian laplacian = self.periodic_laplacian u = a[0] # alias v = a[1] # alias dx = float(self.l[0]) / self.n[0] # FHN right hand side self.rhs_a[0] = u - u ** 3 - v + laplacian(u, dx=dx) self.rhs_a[1] = self.epsilon * (u - self.a1 * v - self.a0) + self.delta * laplacian(v, dx=dx) return self.rhs_a def draw(self, a, t): u = a[0] self.im = plt.imshow(u.real, cmap=&quot;Greys_r&quot;, origin=&#39;lower&#39;, vmin=-0.534522, vmax=0.534522, interpolation=&quot;gaussian&quot;) self.title = plt.title(&#39;time = {:&gt;4.0f}&#39;.format(0)) plt.xticks([]) plt.yticks([]) self.im.figure.canvas.draw() def draw_update(self, a, t): u = a[0] self.title.set_text(&#39;time = {:&gt;4.0f}&#39;.format(t)) self.im.set_data(u.real) self.im.figure.canvas.draw() def save_frame(self, i): fname = &quot;_tmp{:05d}.png&quot;.format(i) self.frame_names.append(fname) self.fig.savefig(fname, bbox_inches=&#39;tight&#39;, dpi=300) def periodic_laplacian(self, u, dx=1): &quot;&quot;&quot;Return finite difference Laplacian approximation of 2d array. Uses periodic boundary conditions and a 2nd order approximation.&quot;&quot;&quot; laplacian = (np.roll(u, -1, axis=0) + np.roll(u, +1, axis=0) + np.roll(u, -1, axis=1) + np.roll(u, +1, axis=1) - 4.0 * u) / (dx ** 2) return laplacian def random_ic(self): return 0.5 * (np.random.random((2, self.n[0], self.n[1])) - 0.5) def blocks_ic(self): a = np.ones((2, self.n[0], self.n[1])) a[0] = 0.534522 a[1] = 0.381802 n = self.n p = n[0] / 8 a[0][3 * p - 4:3 * p + 4, 5 * p - 4:5 * p + 4] = -0.534522 a[0][6 * p - 4:6 * p + 4, 3 * p - 4:3 * p + 4] = -0.534522 return a def squiggle_ic(self): a = np.ones((2, self.n[0], self.n[1])) l = self.l uplus = 0.534522 vplus = 0.381802 uminus = -uplus X, Y = np.meshgrid(np.linspace(0, self.l[0], self.n[0]), np.linspace(0, self.l[0], self.n[0])) cos_term = 0.05 * l[0] * np.sin(10 * (2 * np.pi) * Y / l[1] + np.pi * 0.3) exp_term = np.exp(-((Y - l[1] / 2) / (0.1 * l[1])) ** 2) width = 0.05 * l[0] Z = np.exp(-((X - l[0] / 2 + cos_term * exp_term) / width) ** 2) a[0] = uplus a[1] = vplus a[0][Z &gt; 0.8] = uminus return a . run simulation, save snapshots . plt.ion() plt.clf() foo = FitzHughNagumo() foo.fig = plt.figure(1) ax = foo.fig.add_subplot(111) a = foo.squiggle_ic() mult_a = foo.spectral_multiplier() fft_a = np.fft.fftn(a, axes=(1, 2)) t = foo.start foo.draw(a, t) foo.frame_names = [] foo.save_frame(0) for i, tout in enumerate(np.arange(foo.start + foo.step, foo.finish + foo.step, foo.step)): while t &lt; tout: if foo.integration_type == &quot;spectral&quot;: rhs_a = foo.rhs_reaction(a) fft_a = mult_a * (fft_a + foo.dt * np.fft.fftn(rhs_a, axes=(1, 2))) a = np.fft.ifftn(fft_a, axes=(1, 2)) if foo.integration_type == &quot;euler&quot;: a = a + foo.dt * foo.rhs_euler(a) t += foo.dt foo.draw_update(a, t) foo.save_frame(i + 1) . make movie, delete snapshots . fps = 24 frames = &quot;_tmp%5d.png&quot; movie_command = &quot;ffmpeg -y -r {:} -i {:} fhn.mp4&quot;.format(fps, frames) os.system(movie_command) for fname in foo.frame_names: os.remove(fname) . The semi-spectral method . The explanation below was taken from my thesis: &quot;Pattern Formation in Spatially Forced Systems: Application to Vegetation Restoration&quot;. . The semi-spectral method is extremely useful when working with reaction-diffusion systems, and with parabolic PDEs in general. This was the method used to run all the simulations of the Swift-Hohenberg model in this thesis, and it proved to be reliable and fast. The explanation below is a summary of &quot;Spectral algorithms for reaction-diffusion equations&quot;, by Richard V. Craster and Roberto Sassi, with a step by step recipe, so the reader can easily apply the method to any suitable problem. . the method . The semi-spectral transform method is very useful when we have to integrate a system that evolves really slowly. Let us say we have a (parabolic) system of the form: $$ begin{equation*} u_t= epsilon u + f(u)+D nabla^2u, label{eq:1} tag{1} end{equation*} $$ . where $f(u)$ is a nonlinear function. First, we compute the Fourier transform of eqref{eq:1}: $$ begin{equation*} hat{u}_t= epsilon hat{u} + hat{f}(u)-k^2D hat{u}, label{eq:2} tag{2} end{equation*} $$ where the hat denotes the Fourier transform. . We rearrange eqref{eq:2} in the following way: $$ begin{equation*} hat{u}_t+a hat{u}= hat{f}(u), label{eq:3} tag{3} end{equation*} $$ where $a=- epsilon +k^2D$, and now we make a variable substitution $$ begin{align*} hat{v}(k,t)&amp;= ; hat{u}(k,t) ,e^{at} label{eq:4a} tag{4a} hat{v}_t&amp;= ; hat{u}_te^{at}+a hat{u} ,e^{at}. label{eq:4b} tag{4b} end{align*} $$ . We multiply eqref{eq:3} by $e^{at}$ and we finally get $$ begin{equation*} hat{v}_t=e^{at} hat{f}(u). label{eq:5} tag{5} end{equation*} $$ . We can now advance $ hat{v}$ in time using a simple Euler step $$ begin{equation*} hat{v}^{t_{n+1}}= hat{v}^{t_n}+ Delta t left( e^{at_n} hat{f}(u) right). label{eq:6} tag{6} end{equation*} $$ . What we really want is $ hat{u}$, which, according to eqref{eq:4a}, is given by . $$ begin{align*} displaystyle hat{u}^{t_{n+1}}=&amp; ; hat{v}^{t_{n+1}}e^{-at_{n+1}} label{eq:7a} tag{7a} =&amp; ; hat{v}^{t_{n+1}}e^{-at_{n}}e^{-a Delta t} label{eq:7b} tag{7b} =&amp; ; left( hat{v}^{t_n}+ Delta t ; e^{a t_n} hat{f}(u) right)e^{-at_{n}}e^{-a Delta t} label{eq:7c} tag{7c} =&amp; ; left( hat{v}^{t_n}e^{-at_{n}}+ Delta t ;{e^{a t_n}} hat{f}(u) {e^{-at_{n}}} right)e^{-a Delta t} label{eq:7d} tag{7d} =&amp; ; left( hat{u}^{t_n}+ Delta t hat{f}(u) right)e^{-a Delta t} label{eq:7e} tag{7e}. end{align*} $$There is actually no need to use the variable substitution in eqref{eq:4a}. We now have an expression for $ hat{u}^{t_{n+1}}$: $$ begin{equation*} hat{u}^{t_{n+1}}= left( hat{u}^{t_n}+ Delta t hat{f}(u) right)e^{-a Delta t}. label{eq:8} tag{8} end{equation*} $$ . Now it is time to go back from the Fourier space to the real space, and for that we use an inverse Fourier transform $$ u^{t_{n+1}}= mathcal{F}^{-1}[ hat{u}^{t_{n+1}}]. label{eq:9} tag{9} $$ . step by step . To implement this technique, one just has to follow the steps below: . Calculate the Fourier transform of $u$: $ hat{u}= mathcal{F}[u]$. | Have $f(u)$ calculated and then take its Fourier transform: $ hat{f}(u)= mathcal{F}[f(u)]$. | For a given lattice with $N$ points, and $ delta x$ being the distance between them, make the frequency bin vector (matrix) $k$ for your one (two) dimensional system. In python the command would benumpy.fft.fftfreq(N, dx). . The frequency bin vector $k$ looks like: | . $$ begin{align} k&amp;=2 pi cdot left[ 0,1, cdots, tfrac{N}{2}-1,- tfrac{N}{2}, cdots,-1 right]/(N , delta x), qquad mbox{if N is even;} label{eq:10a} tag{10a} k&amp;=2 pi cdot left[ 0,1, cdots, tfrac{N-1}{2},- tfrac{N-1}{2}, cdots,-1 right]/(N , delta x), qquad mbox{if N is odd.} label{eq:10b} tag{10b} end{align} $$Remember that the domain size is given by $L=N , delta x$, which means that the denominator in the expressions above can be written simply as $L$. It is clear from that fact that $ delta k$, the tiniest slice of the Fourier space is $ delta k=2 pi/L$. Corollary: if you want to divide the Fourier space into very many parts, simply have a huge domain. If the system is two-dimensional, then have $k_x$ and $k_y$ calculated separately. The domain might not be square ($L_x neq L_y$), and you might want to divide the domain into a different number of points ($N_x neq N_y$). Anyway, prepare one-dimensional arrays of $k_x$ and $k_y$ as explained above, and then make an outer product of these arrays with a ones array of length $N$, as following: . $$ k_{x,2d} = begin{pmatrix} 1 1 vdots 1 end{pmatrix} begin{pmatrix} k_{x1} &amp; k_{x2} &amp; ... &amp; k_{xN} end{pmatrix} = begin{pmatrix} k_{x1} &amp; k_{x2} &amp; ... &amp; k_{xN} k_{x1} &amp; k_{x2} &amp; ... &amp; k_{xN} &amp; vdots &amp; &amp; k_{x1} &amp; k_{x2} &amp; ... &amp; k_{xN} end{pmatrix} label{eq:11} tag{11} $$and . $$ k_{y,2d} = begin{pmatrix} k_{x1} k_{x2} vdots k_{xN} end{pmatrix} begin{pmatrix} 1 &amp; 1 &amp; ... &amp; 1 end{pmatrix} = begin{pmatrix} k_{y1} &amp; k_{y1} &amp; &amp; k_{y1} k_{y2} &amp; k_{y2} &amp; ... &amp; k_{y2} vdots &amp; vdots &amp; &amp; vdots k_{yN} &amp; k_{yN} &amp; &amp; k_{yN} end{pmatrix}. label{eq:12} tag{12} $$Then factor $e^{-a Delta t}$ equals . $$ e^{-a Delta t}= e^{ left[ epsilon-D(k_x^2+k_y^2) right] Delta t}, label{eq:13} tag{13} $$where $k_x^2$ is the element-wise exponentiation of the 2d array $k_{x,2d}$. . Now that we have all the factors we need, we simply calculate $$ hat{u}^{t_{n+1}}= left( hat{u}^{t_n}+ Delta t hat{f}(u) right)e^{ left[ epsilon-D(k_x^2+k_y^2) right] Delta t}. label{eq:14} tag{14} $$ | We finally go back to the real space by applying the inverse Fourier transform: $u^{t_{n+1}}= mathcal{F}^{-1}[ hat{u}^{t_{n+1}}]$. | . example . For the parametrically forced Swift-Hohenberg equation $$ frac{ partial u}{ partial t} = [ epsilon + gamma cos(k_f x)]u - u^3 -( nabla^2+k_0^2)^2 u, label{eq:15} tag{15} $$ we have $$ f(u)= -u^3 + gamma u cos(k_f x), qquad a = epsilon - left(k_0- k_x^2 - k_y^2 right)^2. label{eq:16} tag{16} $$ .",
            "url": "https://yairmau.com/jupyter/2020/01/01/fhn.html",
            "relUrl": "/jupyter/2020/01/01/fhn.html",
            "date": " • Jan 1, 2020"
        }
        
    
  
    
        ,"post13": {
            "title": "Double Pendulum",
            "content": ". Introduction . The double pendulum is one of the most famous examples of chaos. Enjoy making your own animations! . The code . comment the lines below if you want interactive mode, i.e., if you want to see the animation in real time. . import matplotlib matplotlib.use(&#39;Agg&#39;) . import matplotlib.pyplot as plt import numpy as np import os from scipy.integrate import ode . define equations of motion and other functions . def equations(t, y, args): &quot;&quot;&quot; the equations for the double pendulum &quot;&quot;&quot; x1 = y[0] # x1 = theta1, angle x2 = y[1] # x2 = theta2, angle p1 = y[2] # p1 = omega1, angular velocity p2 = y[3] # p2 = omega2, angular velocity l1,l2,m1,m2,g = args x1_eq = p1 x2_eq = p2 p1_eq = -((g*(2*m1+m2)*np.sin(x1)+m2*(g*np.sin(x1-2*x2)+2*(l2*p2**2+l1*p1**2*np.cos(x1-x2))*np.sin(x1-x2)))/(2*l1*(m1+m2-m2*(np.cos(x1-x2))**2))) p2_eq = ((l1*(m1+m2)*p1**2+g*(m1+m2)*np.cos(x1)+l2*m2*p2**2*np.cos(x1-x2))*np.sin(x1-x2))/(l2*(m1+m2-m2*(np.cos(x1-x2))**2)) return [x1_eq, x2_eq, p1_eq, p2_eq] def calculate_trajectory(args,time,y0): &quot;&quot;&quot; uses scipy&#39;s ode itegrator to simulate the equations &quot;&quot;&quot; t0,t1,dt = time r = ode(equations).set_integrator(&#39;dopri5&#39;) r.set_initial_value(y0, t0).set_f_params(args) data=[[t0, y0[0], y0[1], y0[2], y0[3] ]] while r.successful() and r.t &lt; t1: r.integrate(r.t+dt) data.append([r.t, r.y[0], r.y[1], r.y[2], r.y[3] ]) return np.array(data) def from_angle_to_xy(args,angles): &quot;&quot;&quot; converts angles into xy positions &quot;&quot;&quot; l1,l2,m1,m2,g = args time,theta1,theta2 = angles.T x1 = l1*np.sin(theta1) y1 = -l1*np.cos(theta1) x2 = l2*np.sin(theta2) + x1 y2 = -l2*np.cos(theta2) + y1 return np.array([time,x1,y1,x2,y2]).T . parameters . l1 = 0.5 # length of arms l2 = 0.5 m1 = 1.0 # mass of the pendulum m2 = 1.0 g = 10.0 # acceleration of gravity args = [l1,l2,m1,m2,g] fps = 80 total_time = 5 # seconds time = [0.0,total_time,1.0/fps] # start, finish, dt ic = [np.pi*0.65, np.pi*1.1, 0.0, 0.0] . here the magic happens . d = calculate_trajectory(args,time,ic) data_TXY = from_angle_to_xy(args,d[:,:3]) . Let&#39;s plot stuff, and make a nice movie. Requrement: ffmpeg . make_movie=True params = {&#39;backend&#39;: &#39;ps&#39;, &#39;font.size&#39;: 20, &#39;font.family&#39;:&#39;serif&#39;, &#39;font.serif&#39;:[&#39;Computer Modern Roman&#39;], # Times, Palatino, New Century Schoolbook, Bookman, Computer Modern Roman &#39;ps.usedistiller&#39;: &#39;xpdf&#39;, &#39;text.usetex&#39;: True, } plt.rcParams.update(params) plt.ion() fig = plt.figure(figsize=(9.6,5.4),dpi=100) # 1920x1080 fig.subplots_adjust(left=0, right=1, top=1, bottom=0,hspace=0.02,wspace=0.02) ax = fig.add_subplot(111) ax.axis(&#39;off&#39;) # no frame def plot_last_seconds(data,index): &quot;&quot;&quot; Plots a line with the trajectory of the tip of pendulum 2 (x2,y2) &quot;&quot;&quot; how_long = 1.0 # seconds n = int(how_long/time[2]) to_plot = data[:index,:] if index &lt; n: prepend = np.tile(data[0],(n-index,1)) to_plot = np.vstack([prepend,to_plot]) index = n colormap = plt.cm.Greys_r colors = [colormap(i) for i in np.linspace(0.0, 1.0, n-1)] plots = [] for j in np.arange(n-1): p, = ax.plot(to_plot[index-j-1:index-j+1,3],to_plot[index-j-1:index-j+1,4], color=colors[j], zorder=-1) plots.append(p) return plots # &quot;plot&quot; returns a tuple of line objects, thus the comma t,x1,y1,x2,y2 = data_TXY[0] line1, = ax.plot([0.0,x1], [0.0,y1], &#39;r-&#39;) line2, = ax.plot([x1,x2], [y1,y2], &#39;r-&#39;) circ1, = ax.plot([x1], [y1], &#39;ro&#39;,markersize=10) circ2, = ax.plot([x2], [y2], &#39;ro&#39;,markersize=10) sizeY = 1.2 ax.axis([-sizeY*16/9,sizeY*16/9,-sizeY,sizeY]) frame_names = [] tex=ax.text(0.0,0.85,&#39;&#39;,ha=&quot;center&quot;) for i,v in enumerate(data_TXY): t,x1,y1,x2,y2 = v # print(&quot;t={:.2f}&quot;.format(t)) # you might want to know how things are going... line1.set_data([0.0,x1],[0.0,y1]) line2.set_data([x1,x2],[y1,y2]) circ1.set_data([x1],[y1]) circ2.set_data([x2],[y2]) # plot_last_seconds considerably slows down the simulation, # but makes it much prettier... pls = plot_last_seconds(data_TXY,i+1) tex.set_text(r&quot;$t={:.3f}$ s&quot;.format(t)) fig.canvas.draw() if make_movie: fname = &quot;_tmp{:05d}.png&quot;.format(i) frame_names.append(fname) fig.savefig(fname,bbox_inches=&#39;tight&#39;) for k in pls: k.remove() if make_movie: frames = &quot;_tmp%5d.png&quot; frames = &quot;_tmp%5d.png&quot; movie_command = &quot;ffmpeg -y -r {:} -i {:} double.mp4&quot;.format(fps,frames) os.system(movie_command) for fname in frame_names: os.remove(fname) .",
            "url": "https://yairmau.com/jupyter/2020/01/01/doublependulum.html",
            "relUrl": "/jupyter/2020/01/01/doublependulum.html",
            "date": " • Jan 1, 2020"
        }
        
    
  
    
        ,"post14": {
            "title": "Contour plots",
            "content": ". Introduction . Contour plots are great to show how a variable depends on two parameters. . The code . import numpy as np import matplotlib.pyplot as plt import matplotlib from IPython.display import Math # %matplotlib inline . configure plotting preferences . # http://wiki.scipy.org/Cookbook/Matplotlib/LaTeX_Examples # this is a latex constant, don&#39;t change it. pts_per_inch = 72.27 # write &quot; the textwidth&quot; (or &quot; showthe columnwidth&quot; for a 2 collumn text) text_width_in_pts = 246.0 # inside a figure environment in latex, the result will be on the # dvi/pdf next to the figure. See url above. text_width_in_inches = text_width_in_pts / pts_per_inch # make rectangles with a nice proportion golden_ratio = 0.618 # figure.png or figure.eps will be intentionally larger, because it is prettier inverse_latex_scale = 2 # when compiling latex code, use # includegraphics[scale=(1/inverse_latex_scale)]{figure} # we want the figure to occupy 2/3 (for example) of the text width fig_proportion = (3.0 / 3.0) csize = inverse_latex_scale * fig_proportion * text_width_in_inches # always 1.0 on the first argument fig_size = (1.0 * csize,golden_ratio * csize) # find out the fontsize of your latex text, and put it here text_size = inverse_latex_scale * 12 tick_size = inverse_latex_scale * 8 # learn how to configure: # http://matplotlib.sourceforge.net/users/customizing.html params = {&#39;backend&#39;: &#39;ps&#39;, &#39;axes.labelsize&#39;: text_size, &#39;legend.fontsize&#39;: tick_size, &#39;legend.handlelength&#39;: 2.5, &#39;legend.borderaxespad&#39;: 0, &#39;xtick.labelsize&#39;: tick_size, &#39;ytick.labelsize&#39;: tick_size, &#39;font.family&#39;: &#39;serif&#39;, &#39;font.size&#39;: text_size, # Times, Palatino, New Century Schoolbook, # Bookman, Computer Modern Roman &#39;font.serif&#39;: [&#39;Times&#39;], &#39;ps.usedistiller&#39;: &#39;xpdf&#39;, &#39;text.usetex&#39;: True, &#39;figure.figsize&#39;: fig_size, # include here any neede package for latex &#39;text.latex.preamble&#39;: [r&#39; usepackage{amsmath}&#39;, ], } plt.rcParams.update(params) plt.ioff() plt.clf() # figsize accepts only inches. fig = plt.figure(1, figsize=fig_size) fig.subplots_adjust(left=0.12, right=0.96, top=0.96, bottom=0.18, hspace=0.02, wspace=0.02) ax = fig.add_subplot(111) . def truncate_colormap(cmap, minval=0.0, maxval=1.0, n=256): new_cmap = matplotlib.colors.LinearSegmentedColormap.from_list( &#39;trunc({n},{a:.2f},{b:.2f})&#39;.format(n=cmap.name, a=minval, b=maxval), cmap(np.linspace(minval, maxval, n))) return new_cmap cmap = plt.get_cmap(&#39;YlOrBr&#39;) my_cmap = truncate_colormap(cmap, 0.2, 0.9) . minX = 0 maxX = 10 minY = 0 maxY = 3 N = 50j y, x = np.mgrid[minY:maxY:N, minX:maxX:N] z = 2 * np.exp(-(0.02 * (x + 1) ** 2 + 0.05 * (y - 3.1) **2 )) divisions = np.arange(0.3, 2.1, 0.3) divisions2 = np.append(divisions, 2.5) divisions2 = np.append(-0.5, divisions2) # contour filled with colors ax.contourf(x, y, z, divisions2, cmap=my_cmap, vmin=0.0,vmax=2.0) # contour lines cont = ax.contour(x, y, z, divisions, colors=2 * [&#39;black&#39;] + [&#39;green&#39;] + 3 * [&#39;black&#39;], linewidth=.5) zcontour = cont.collections[1] dash1=(15, 10, 15, 10) zcontour.set_dashes([(0, dash1)]) zcontour = cont.collections[4] dash2=(20, 30) zcontour.set(color=&#39;blue&#39;, linestyle=[(0, dash2)], linewidth=4) # labels manual_locations = [(1.0, 2.5), (2.5, 2.5), (3.8, 2.5), (5.0, 2.5), (6.2, 2.5), (8.3, 2.5)] ax.clabel(cont, inline=1, fontsize=tick_size, fmt=&#39;z=%.2f%%&#39;, manual=manual_locations, colors=5 * [&#39;black&#39;] + [&#39;white&#39;]) ax.set_xlabel(r&quot;$x$ axis&quot;) ax.set_ylabel(r&quot;$y$ axis&quot;) fig . /Users/yairmau/opt/anaconda3/lib/python3.7/site-packages/ipykernel_launcher.py:18: UserWarning: The following kwargs were not used by contour: &#39;linewidth&#39; . %matplotlib notebook fig.savefig(&quot;./python_figures/contours.png&quot;,dpi=300) # fig.savefig(&quot;cont.eps&quot;) .",
            "url": "https://yairmau.com/jupyter/2020/01/01/contours.html",
            "relUrl": "/jupyter/2020/01/01/contours.html",
            "date": " • Jan 1, 2020"
        }
        
    
  
    
        ,"post15": {
            "title": "What's the best path to save someone from drowning?",
            "content": ". Introduction . Snell&#39;s law of refraction can be understood in this example, where the lifeguard wants to minimize the time it takes to get to the drowning person. . Code . import matplotlib import matplotlib.pyplot as plt import numpy as np . # http://wiki.scipy.org/Cookbook/Matplotlib/LaTeX_Examples # this is a latex constant, don&#39;t change it. pts_per_inch = 72.27 # write &quot; the textwidth&quot; (or &quot; showthe columnwidth&quot; for a 2 collumn text) text_width_in_pts = 252.0 # inside a figure environment in latex, the result will be on the # dvi/pdf next to the figure. See url above. text_width_in_inches = text_width_in_pts / pts_per_inch # make rectangles with a nice proportion golden_ratio = 0.618 # figure.png or figure.eps will be intentionally larger, because it is prettier inverse_latex_scale = 2 # when compiling latex code, use # includegraphics[scale=(1/inverse_latex_scale)]{figure} # we want the figure to occupy 2/3 (for example) of the text width fig_proportion = (3.0 / 3.0) csize = inverse_latex_scale * fig_proportion * text_width_in_inches # always 1.0 on the first argument fig_size = (1.0 * csize,golden_ratio * csize) # find out the fontsize of your latex text, and put it here text_size = inverse_latex_scale * 12 tick_size = inverse_latex_scale * 8 # learn how to configure: # http://matplotlib.sourceforge.net/users/customizing.html params = {&#39;axes.labelsize&#39;: text_size, &#39;legend.fontsize&#39;: tick_size, &#39;legend.handlelength&#39;: 2.5, &#39;legend.borderaxespad&#39;: 0, &#39;xtick.labelsize&#39;: tick_size, &#39;ytick.labelsize&#39;: tick_size, &#39;font.family&#39;: &#39;serif&#39;, &#39;font.size&#39;: text_size, # Times, Palatino, New Century Schoolbook, # Bookman, Computer Modern Roman # &#39;font.serif&#39;: [&#39;Times&#39;], # &#39;ps.usedistiller&#39;: &#39;xpdf&#39;, &#39;text.usetex&#39;: True, &#39;figure.figsize&#39;: fig_size, # include here any neede package for latex &#39;text.latex.preamble&#39;: [r&#39; usepackage{amsmath}&#39;, ], } plt.rcParams.update(params) # plt.clf() # figsize accepts only inches. plt.ioff() fig = plt.figure(1, figsize=fig_size) fig.subplots_adjust(left=0.0, right=1.0, top=1.0, bottom=0.0, hspace=0.02, wspace=0.02) ax = fig.add_subplot(111) . origin = [0, 0] lifeguard = [-3, -2] drowning = [2, 3] ax.set_xticks([]) ax.set_yticks([]) xlim = [-4, 4] ylim = [-4, 4] ax.axis([xlim[0], xlim[1], ylim[0], ylim[1]]) ##### drowning ##### # line ax.plot([origin[0], drowning[0]], [origin[1], drowning[1]], color=&quot;black&quot;, lw=2) # diamond ax.plot(drowning[0], drowning[1], &quot;D&quot;, markerfacecolor=&quot;black&quot;, markersize=10, markeredgewidth=3, color=&quot;black&quot;) # explanation ax.text(drowning[0], drowning[1] - 0.3, r&quot;drowning&quot;, verticalalignment=&quot;top&quot;) ax.text(drowning[0], drowning[1] - 0.8, r&quot;person&quot;, verticalalignment=&quot;top&quot;) ##### lifeguard ##### # line ax.plot([origin[0], lifeguard[0]], [origin[1], lifeguard[1]], color=&quot;black&quot;, lw=2) # circle ax.plot(lifeguard[0], lifeguard[1], &quot;o&quot;, markerfacecolor=&quot;black&quot;, markersize=10, markeredgewidth=3, color=&quot;black&quot;) # explanation ax.text(lifeguard[0], lifeguard[1] - 0.3, r&quot;lifeguard&quot;, verticalalignment=&quot;top&quot;) . Text(-3, -2.3, &#39;lifeguard&#39;) . background colors . sand = matplotlib.patches.Rectangle([xlim[0], ylim[0]], (xlim[1] - xlim[0]), (ylim[1] - ylim[0]) / 2.0, color=&quot;yellow&quot;, alpha=0.6) ax.add_patch(sand) sea = matplotlib.patches.Rectangle([xlim[0], 0], (xlim[1] - xlim[0]), (ylim[1] - ylim[0]) / 2.0, color=&quot;blue&quot;, alpha=0.4) ax.add_patch(sea) ###### sand ##### ax.text(0.95, 0.05, r&quot;(1) sand&quot;, transform=ax.transAxes, horizontalalignment=&#39;right&#39;) ###### sea ##### ax.text(0.95, 0.50, r&quot;(2) sea&quot;, transform=ax.transAxes, horizontalalignment=&#39;right&#39;, verticalalignment=&quot;bottom&quot;) . Text(0.95, 0.5, &#39;(2) sea&#39;) . spines through origin . # http://matplotlib.org/examples/pylab_examples/spine_placement_demo.html ax.spines[&#39;left&#39;].set_position(&#39;zero&#39;) ax.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax.spines[&#39;bottom&#39;].set_position(&#39;zero&#39;) ax.spines[&#39;top&#39;].set_color(&#39;none&#39;) ax.spines[&#39;left&#39;].set_smart_bounds(False) ax.spines[&#39;bottom&#39;].set_smart_bounds(False) # ax.xaxis.set_ticks_position(&#39;bottom&#39;) # ax.yaxis.set_ticks_position(&#39;left&#39;) ax.set_xticks([]) ax.set_yticks([]) . [] . annotations . # h_1 ax.annotate(&quot;&quot;, xy=(lifeguard[0] - 0.3, lifeguard[1]), xycoords=&#39;data&#39;, xytext=(lifeguard[0] - 0.3, 0), textcoords=&#39;data&#39;, size=tick_size, arrowprops=dict(arrowstyle=&quot;&lt;-&gt;&quot;, connectionstyle=&quot;arc3&quot;), ) ax.text(lifeguard[0] - 0.2, lifeguard[1] / 2.0, r&quot;$h_1$&quot;, verticalalignment=&quot;center&quot;, horizontalalignment=&quot;left&quot;) # h_2 ax.annotate(&quot;&quot;, xy=(lifeguard[0] - 0.3, drowning[1]), xycoords=&#39;data&#39;, xytext=(lifeguard[0] - 0.3, 0), textcoords=&#39;data&#39;, size=tick_size, arrowprops=dict(arrowstyle=&quot;&lt;-&gt;&quot;, connectionstyle=&quot;arc3&quot;), ) ax.text(lifeguard[0] - 0.2, drowning[1] / 2.0, r&quot;$h_2$&quot;, verticalalignment=&quot;center&quot;, horizontalalignment=&quot;left&quot;) # L ax.annotate(&quot;&quot;, xy=(lifeguard[0], drowning[1] + 0.3), xycoords=&#39;data&#39;, xytext=(drowning[0], drowning[1] + 0.3), textcoords=&#39;data&#39;, size=tick_size, arrowprops=dict(arrowstyle=&quot;&lt;-&gt;&quot;, shrinkA=0, shrinkB=0, connectionstyle=&quot;arc3&quot;), ) ax.text((lifeguard[1] - lifeguard[0]) / 2.0, drowning[1] + 0.3, r&quot;$L$&quot;, verticalalignment=&quot;bottom&quot;, horizontalalignment=&quot;left&quot;) # l1 ax.text(lifeguard[0] / 2.0, 1.10 * lifeguard[1] / 2.0, r&quot;$ ell_1$&quot;, verticalalignment=&quot;top&quot;, horizontalalignment=&quot;left&quot;) # l2 ax.text(drowning[0] / 2.0, 0.95 * drowning[1] / 2.0, r&quot;$ ell_2$&quot;, verticalalignment=&quot;top&quot;, horizontalalignment=&quot;left&quot;) # theta_1 ax.annotate(&quot;&quot;, xy=(0, 0.5 * lifeguard[1]), xycoords=&#39;data&#39;, xytext=(0.2 * lifeguard[0], 0.2 * lifeguard[1]), textcoords=&#39;data&#39;, size=tick_size, arrowprops=dict(arrowstyle=&quot;-&quot;, lw=2, connectionstyle=&quot;angle3,angleA=-60,angleB=0&quot;), ) ax.text(0.1 * lifeguard[0], 0.5 * lifeguard[1], r&quot;$ theta_1$&quot;, verticalalignment=&quot;top&quot;, horizontalalignment=&quot;right&quot;) # theta_2 ax.annotate(&quot;&quot;, xy=(0, 0.3 * drowning[1]), xycoords=&#39;data&#39;, xytext=(0.2 * drowning[0], 0.2 * drowning[1]), textcoords=&#39;data&#39;, size=tick_size, arrowprops=dict(arrowstyle=&quot;-&quot;, lw=2, connectionstyle=&quot;angle3,angleA=120,angleB=0&quot;), ) ax.text(0.1 * drowning[0], 0.5 * drowning[1], r&quot;$ theta_2$&quot;, verticalalignment=&quot;top&quot;, horizontalalignment=&quot;left&quot;) . Text(0.2, 1.5, &#39;$ theta_2$&#39;) . %matplotlib inline fig.savefig(&quot;python_figures/bestpath.png&quot;, dpi=300) fig .",
            "url": "https://yairmau.com/jupyter/2020/01/01/bestpath.html",
            "relUrl": "/jupyter/2020/01/01/bestpath.html",
            "date": " • Jan 1, 2020"
        }
        
    
  
    
        ,"post16": {
            "title": "Bar plot",
            "content": ". Introduction . This code produces the figure above. Here we showcase the use of unicode text. . The code . from __future__ import unicode_literals import numpy as np import matplotlib import matplotlib.pyplot as plt from bidi import algorithm as bidialg # needed for arabic, hebrew import arabic_reshaper # needed for arabic . # http://wiki.scipy.org/Cookbook/Matplotlib/LaTeX_Examples pts_per_inch = 72.27 # this is a latex constant, don&#39;t change it. text_width_in_pts = 300.0 # write &quot; the textwidth&quot; (or &quot; showthe columnwidth&quot; for a 2 collumn text) # inside a figure environment in latex, the result will be on the dvi/pdf next to the figure. See url above. text_width_in_inches=text_width_in_pts/pts_per_inch golden_ratio = 0.618 # make rectangles with a nice proportion inverse_latex_scale = 2 # figure.png or figure.eps will be intentionally larger, because it is prettier # when compiling latex code, use includegraphics[scale=(1/inverse_latex_scale)]{figure} fig_proportion = (3.0 / 3.0) # we want the figure to occupy 2/3 (for example) of the text width csize = inverse_latex_scale * fig_proportion * text_width_in_inches fig_size = (1 * csize, 1.3 * csize) # always 1.0 on the first argument text_size = inverse_latex_scale * 10 # find out the fontsize of your latex text, and put it here label_size = inverse_latex_scale * 10 tick_size = inverse_latex_scale * 8 # learn how to configure: # http://matplotlib.sourceforge.net/users/customizing.html params = {&#39;backend&#39;: &#39;ps&#39;, &#39;axes.labelsize&#39;: 16, &#39;legend.fontsize&#39;: 14, &#39;legend.handlelength&#39;: 2.5, &#39;legend.borderaxespad&#39;: 0, &#39;axes.labelsize&#39;: label_size, &#39;xtick.labelsize&#39;: tick_size, &#39;ytick.labelsize&#39;: tick_size, # &#39;font.family&#39;: &#39;serif&#39;, &#39;font.size&#39;: text_size, # &#39;font.serif&#39;: [&#39;Computer Modern Roman&#39;], &#39;ps.usedistiller&#39;: &#39;xpdf&#39;, # &#39;text.usetex&#39;: True, &#39;figure.figsize&#39;: fig_size, #&#39;text.latex.unicode&#39;: True, } plt.rcParams.update(params) plt.ioff() fig = plt.figure(1, figsize=fig_size) # figsize accepts only inches. fig.clf() dpi = 100 pixel_size = (700,700) fig_size = (pixel_size[0]/dpi,pixel_size[1]/dpi) ax1=fig.add_subplot(211) ax2=fig.add_subplot(212) fig.subplots_adjust(left=0.30, right=0.97, top=0.95, bottom=0.06, hspace=0.2, wspace=0.1) . words = [u&#39;Fußball Ångström nsøster Россия&#39;, u&#39;français maître nvoilà égoïste&#39;, u&#39;España&#39;, u&#39;İstanbul ağzı&#39;, u&#39;Anything Unicode&#39; ] values1 = [2575, 5851, 3191, 2303, 3029] values2 = [4813, 5219, 5505, 6229, 6961] values1 = np.array(values1) values2 = np.array(values2) width = 0.35 # the width of the bars r = np.arange(len(values1)) . ax1 , horizontal bars . v1 = ax1.barh(r, values1, width, color=&#39;pink&#39;) v2 = ax1.barh(r + width, values2, width, color=&#39;brown&#39;) ax1.axis([0, 8600, r.min() - 0.3, r.max() + 1]) ax1.set_yticks(r) ax1.set_yticks(r + 1 * width) ax1.set_yticklabels(words) xt = np.arange(0, 8100, 1000) ax1.set_xticks(xt) ax1.set_xticklabels(xt) ax1.set_xlabel(u&#39;the values&#39;, fontsize=16) ax1.set_title(u&#39;Title here&#39;, fontsize=18) ax1.xaxis.grid(True) ax1.tick_params( axis=&#39;y&#39;, # changes apply to the y-axis which=&#39;both&#39;, # both major and minor ticks are affected left=&#39;off&#39;, # ticks along the left edge are off right=&#39;off&#39;, # ticks along the right edge are off labelleft=&#39;on&#39;) # labels along the bottom edge are on ax1.legend((v1, v2), (u&#39;2016&#39;, u&#39;2015&#39;), loc=(0.74,0.05)) def autolabel_hor(rects,ax, offset_x, offset_y): # attach some text labels at the tip of the bars for i,rect in enumerate(rects): width = rect.get_width() height = rect.get_height() ax.text(width + offset_x, rect.get_y() + offset_y * height, &#39;%d&#39; % int(width), ha=&#39;left&#39;, va=&#39;bottom&#39;, fontsize=14) autolabel_hor(v1, ax1, 100.0, -0.20) autolabel_hor(v2, ax1, 100.0, -0.10) . ax2, vertical bars . from bidi import algorithm as bidialg w1 = ax2.bar(r, values1, width, color=&#39;pink&#39;) w2 = ax2.bar(r + width, values2, width, color=&#39;brown&#39;) ax2.axis([r.min() - 0.3, r.max() + 1, 0, 8600]) ax2.set_xticks(r) ax2.set_xticks(r + 1 * width) shalom = bidialg.get_display(u&#39;שלום&#39;) salam = bidialg.get_display(arabic_reshaper.reshape(u&#39;سلام&#39;)) ax2.set_xticklabels([shalom, salam, &#39;ccc&#39;, &#39;ddd&#39;, &#39;eee&#39;]) xt = np.arange(0, 8200, 1000) ax2.set_yticks(xt) ax2.set_yticklabels(xt) ax2.yaxis.grid(True) ax2.tick_params( axis=&#39;x&#39;, # changes apply to the x-axis which=&#39;both&#39;, # both major and minor ticks are affected top=&#39;off&#39;, # ticks along the top edge are off bottom=&#39;off&#39;, # ticks along the bottom edge are off labelbottom=&#39;on&#39;) # labels along the bottom edge are on ax2.legend((w1, w2), (u&#39;2016&#39;, u&#39;2015&#39;), loc=&quot;upper center&quot;) def autolabel_ver(rects,ax, offset_x, offset_y): # attach some text labels at the tip of the bars for i,rect in enumerate(rects): width = rect.get_width() height = rect.get_height() ax.text(rect.get_x() + offset_x * width, height + offset_y, &#39;%d&#39; % int(height), ha=&#39;left&#39;, va=&#39;bottom&#39;, fontsize=14) autolabel_ver(w1, ax2, -0.3, 100.0) autolabel_ver(w2, ax2, 0., 100.0) . %matplotlib inline fig.savefig(&quot;./python_figures/bars.png&quot;) plt.show() fig .",
            "url": "https://yairmau.com/jupyter/2020/01/01/bars.html",
            "relUrl": "/jupyter/2020/01/01/bars.html",
            "date": " • Jan 1, 2020"
        }
        
    
  

  
  
      ,"page0": {
          "title": "",
          "content": "Senior Lecturer [Assistant Professor] The Hebrew University of Jerusalem The Department of Soil and Water Sciences Robert H. Smith Faculty of Agriculture, Food and Environment . About . I’m interested in the interactions between soil, water and vegetation in drylands, in both natural and agricultural ecosystems. Our goal is to understand how the basic processes and feedbacks influence the ecosystem dynamics, and how this knowledge can be used to control those systems. . The common theme between my different research projects is land/ecosystem degradation caused by human activity. . Our research is based on “simple” mathematical models, that strive to capture the essential physical processes, while providing deep insight into the dynamics of the system. Some of the tools we use in the modeling of environmental questions come from dynamical systems, statistical physics and optimal control theory. . [Read more on current research projects…] . I love to write code, and I made available on the Tutorials page some working examples in Python and LaTeX. Check it out! . How to find me .   yair.mau@mail.huji.ac.il   +972 8 948 9386   Rehovot Campus, Lubell building, office 19. Map here . Google Scholar Check out my CV . . Piet Hein Problems worthy   of attack prove their worth   by hitting back. .",
          "url": "https://yairmau.com/inde_old.html",
          "relUrl": "/inde_old.html",
          "date": ""
      }
      
  

  
      ,"page1": {
          "title": "",
          "content": "Senior Lecturer [Assistant Professor] The Hebrew University of Jerusalem The Department of Soil and Water Sciences Robert H. Smith Faculty of Agriculture, Food and Environment . About . I’m interested in the interactions between soil, water and vegetation in drylands, in both natural and agricultural ecosystems. Our goal is to understand how the basic processes and feedbacks influence the ecosystem dynamics, and how this knowledge can be used to control those systems. . The common theme between my different research projects is land/ecosystem degradation caused by human activity. . Our research is based on “simple” mathematical models, that strive to capture the essential physical processes, while providing deep insight into the dynamics of the system. Some of the tools we use in the modeling of environmental questions come from dynamical systems, statistical physics and optimal control theory. . [Read more on current research projects…] . I love to write code, and I made available on the Tutorials page some working examples in Python and LaTeX. Check it out! . How to find me .   yair.mau@mail.huji.ac.il   +972 8 948 9386   Rehovot Campus, Lubell building, office 19. Map here . Google Scholar Check out my CV . . Piet Hein Problems worthy   of attack prove their worth   by hitting back. .",
          "url": "https://yairmau.com/index%20(1).html",
          "relUrl": "/index%20(1).html",
          "date": ""
      }
      
  

  

  
      ,"page3": {
          "title": "Surface Hydrology",
          "content": "Surface Hydrology . . Some notebooks I’m preparing . Introduction . Jupyter notebook . Return period . Jupyter notebook . Was Bilbao’s 1983 “freak” flood such an unexpected event? How often should we expect very large downpours? .",
          "url": "https://yairmau.com/teaching/hydrology/",
          "relUrl": "/teaching/hydrology/",
          "date": ""
      }
      
  

  
      ,"page4": {
          "title": "Science Communication",
          "content": "Science Communication . . Talks . A scientific talk is not a scientific paper, it is a completely different medium! Here are a few tips that I find useful. . ![](/images/phd-comics-presentation.jpg) Cartoon by Jorge Cham How To Give a Talk . [How To Give a Talk, by David L Stern.] . Excerpt: . Principle 1 - Don’t Put Words On Slides It may not seem intuitive, but including words on slides has a bigger detrimental effect on the quality of a talk than any other issue I will address. . The slides in most science talks contain many words. This simple fact has many consequences, none positive. Most obviously, words on slides impel listeners to read the words on the slide. If you are talking while they are reading, then you generate cognitive dissonance that makes it difficult for the audience to understand either your spoken words or your written words. So, if you want your audience to read the words on a slide, then, presumably, you should shut up. But, I don’t recommend that. Instead, just cut all the words form your slides. . The David Attenborough Style of Scientific Presentation . [The David Attenborough Style of Scientific Presentation.] . Excerpt: . Get into this mindset: your main job is to be an entertainer, not a scientist. Most scientists don’t do this, which is why most scientific talks are bad. The fact of the matter is that if the audience doesn’t understand and enjoy your talk, they won’t care if your science is good. . A LaTeX template . Check out a nice LaTeX template for presentations [here]. . . Visualizations . Visualizations can take a message very, very far. I put a lot of thinking into how to best express an idea. I believe that great graphs greatly improve a scientific paper, and a thoughful graph/animation surely brings home the main point of a talk. Here are a few thoughts on visualizations. . Inspiration . Hans Rosling, Gapminder | Max Roser, Our World in Data | Stephen Malinowski, Music Animation Machine | The Economist, Daily Chart | . Colors . Don’t use the rainbow color map. Why? [Read this], by Robert Kosara. . So how should you choose the colors for a graph? . Visit colorbrewer. It gives sequential, diverging and qualitative colormaps that can be chosen to be “colorblind safe”, “print safe”, or “photocopy safe”. Usually, it is the first and only tool I use. It’s just great! | Visit Adobe Color CC. It gives you much more freedom to play with the colors than colorbrewer. Use it wisely! | . More on color: read Subtleties of Color, by Robert Simmon. . Browse for ideas . The Data Visualisation Catalogue | .",
          "url": "https://yairmau.com/more/communication/",
          "relUrl": "/more/communication/",
          "date": ""
      }
      
  

  
      ,"page5": {
          "title": "Tools",
          "content": "Tools . . /home/more/tools . Programming . Anaconda . “The easiest way to perform Python/R data science and machine learning on Linux, Windows, and Mac OS X.” . Sublime Text . “Sublime Text is a sophisticated text editor for code, markup and prose.” . Jupyter Notebook . “The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text.” . CodeCademy . “Learn to code interactively, for free.” . Documents . PDFtk . “Use PDFtk Pro to quickly split, merge, rotate, watermark, stamp and secure PDF pages and documents” Command line version (powerful, see examples); friendly graphical tool for Windows. . Overleaf . “An online LaTeX editor that’s easy to use.” By the way, Overleaf has the best LaTeX tutorials out there. Check it out. Also, see this excellent WikiBook on LaTeX. . BRISS . “A simple cross-platform (Linux, Windows, Mac OSX) application for cropping PDF files” . Data . Figshare . “Figshare is an online digital repository where researchers can preserve and share their research outputs, including figures, datasets, images, and videos.” . BitBucket . “Bitbucket is a web-based hosting service for projects that use Git revision control systems.” . WebPlotDigitizer . “Extract data from plots, images, and maps.” . $ rightarrow LaTeX$ . doi2bib . “Give us a DOI and we’ll do our best to get you the BibTeX entry.” . Tables Generator . “Quickly create even complex LaTeX tables online with our generator – cells merging is supported together with borders editing.” .",
          "url": "https://yairmau.com/more/tools/",
          "relUrl": "/more/tools/",
          "date": ""
      }
      
  

  
      ,"page6": {
          "title": "More",
          "content": "Teaching . Tools I recommend . Quotes . Science Communication . Five-star Content . Blog .",
          "url": "https://yairmau.com/more/",
          "relUrl": "/more/",
          "date": ""
      }
      
  

  
      ,"page7": {
          "title": "Research",
          "content": "Research . . Interests . I’m interested in the interactions between soil, water and vegetation in drylands, in both natural and agricultural ecosystems. Our goal is to understand how the basic processes and feedbacks influence the ecosystem dynamics, and how this knowledge can be used to control those systems. . The common theme between my different research projects is land/ecosystem degradation caused by human activity. . Our research is based on “simple” mathematical models, that strive to capture the essential physical processes, while providing deep insight into the dynamics of the system. Some of the tools we use in the modeling of environmental questions come from dynamical systems, statistical physics and optimal control theory. . We are recruiting excellent students to our group! Here you can find some more detail on our current projects. . Projects . Soil salinization . Every week, the world loses an area greater than Manhattan to salt-related soil degradation. It is estimated that 20% of all irrigated lands are affected by salinity, with an even higher fraction of salt-degraded soils in arid and semiarid regions. Salt accumulation in the soil, usually induced by insufficient drainage and poor-quality irrigation water, imposes severe restrictions on food production. . Some of the questions we’d like to answer are: On what time scales the salinization process occurs, and what is the effect of a drier and more extreme climate on the salt buildup? What are the critical thresholds for (irreversible) soil degradation? How can we rehabilitate a degraded soil by making optimal use of the resources available? What role can treated wastewater have on dryland agriculture that is sustainable with respect to the ecosystem services? ​ . Nutrient dynamics . Nitrogen management is of critical importance to food security and environmental sustainability. Because of artificial fertilizers, we have seen a sharp increase in agricultural production in the last century. However, the same nitrogen available to plant uptake, can polute the groundwater, streams and lakes, and be released as nitrous oxide, a potent greenhouse gas. . We would like to understand how the nonlinear dynamics of nitrogen and carbon cycling is influenced by the hydrological cycle. In particular, we would like to study the influence of random rainfall events and a changing climate in driving these cycles. . Tree water balance in a semiarid pine forest and rates of survival under global climate change . Longer droughts and temperature rise impose severe risks of widespread forest mortality. Drought-adapted trees in semiarid and arid ecosystems cope with water stress by regulating their transpiration rate, thus saving internal water content and avoiding runaway decline in water potential. . Our goal is to characterize how trees manage their water budget in order to increase survival probability under prolonged drought periods. . Our group will approach these objectives by modeling the soil-tree-atmosphere water transport to assess tree survival probability for current and future climate scenarios. A collaboration with an experimental group will provide us data from a research station in the Yatir forest, in the Negev desert (see map above). . Studying the fate of the Yatir forest gives us a window into the future, for it is expected that many ecosystems around the world will face increasing drought stress as a result of climate change. .",
          "url": "https://yairmau.com/research/",
          "relUrl": "/research/",
          "date": ""
      }
      
  

  
      ,"page8": {
          "title": "Publications",
          "content": "Publications . . Xing Chen, Mukesh Kumar, Daniel de B. Richter, and Yair Mau. Impact of gully incision on hillslope hydrology. Hydrological Processes, 2020. doi: 10.1002/hyp.13845 Abstract   BibTeX   PDF . The Southern U.S. Piedmont ranging from Virginia to Georgia underwent severe gully erosion over a century of farming mainly for cotton (1800s to 1930s). Although tree succession blanketed much of this region by the middle 20th century, gully erosion still occurs, especially during wet seasons. While many studies on gully erosion have focused on soil loss, soil carbon exchange, and stormwater response, the impacts on soil moisture, groundwater, and transpiration remain understudied. Using a newly developed 2D hydrologic model, this study analyzes the impacts of gully erosion on hillslope hydrologic states and fluxes. Results indicate that increases in gully incision lead to reduction in groundwater table, root zone soil moisture, and transpiration. These reductions show seasonal variations, but the season when the reduction is maximum differs among the hydrologic variables. Spatially, the impacts are generally the greatest near the toe of the hillslope and reduce further away from it, although the reductions are sometimes non‐monotonic. Overall, the impacts are larger for shallow gully depths and diminish as the incision goes deeper. Lastly, the extent of impacts on a heterogeneous hillslope is found to be very different with respect to a homogeneous surrogate made of dominant soil properties. These results show that through gully erosion, the landscape not only loses soil but also a large amount of water from the subsurface. The magnitude of water loss is, however, dependent on hydrogeologic and topographic configuration of the hillslope. The results will facilitate (a) mapping of relative susceptibility of landscapes to gullying, (b) understanding of the impacts of stream manipulations such as due to dredging on hillslope eco‐hydrology, (c) prioritization of mitigation measures to prevent gullying, and (d) design of observation campaigns to assess the impacts of gullying on hydrologic response. @article{Chen2020,&nbsp;&nbsp; doi = {10.1002/hyp.13845},&nbsp;&nbsp; url = {https://doi.org/10.1002/hyp.13845},&nbsp;&nbsp; year = {2020},&nbsp;&nbsp; publisher = {Wiley},&nbsp;&nbsp; author = {Xing Chen and Mukesh Kumar and Daniel B. Richter and Yair Mau},&nbsp;&nbsp; title = {Impact of gully incision on hillslope hydrology},&nbsp;&nbsp; journal = {Hydrological Processes}} Yair Mau and Amilcare Porporato. Optimal control solutions to sodic soil reclamation. Advances in Water Resources, 91:37–45, 2016. doi: 10.1016/j.advwatres.2016.02.014 Abstract   BibTeX   PDF . We study the reclamation process of a sodic soil by irrigation with water amended with calcium cations. In order to explore the entire range of time-dependent strategies, this task is framed as an optimal control problem, where the amendment rate is the control and the total rehabilitation time is the quantity to be minimized. We use a minimalist model of vertically averaged soil salinity and sodicity, in which the main feedback controlling the dynamics is the nonlinear coupling of soil water and exchange complex, given by the Gapon equation. We show that the optimal solution is a bang–bang control strategy, where the amendment rate is discontinuously switched along the process from a maximum value to zero. The solution enables a reduction in remediation time of about 50%, compared with the continuous use of good-quality irrigation water. Because of its general structure, the bang–bang solution is also shown to work for the reclamation of other soil conditions, such as saline–sodic soils. The novelty in our modeling approach is the capability of searching the entire “strategy space” for optimal time-dependent protocols. The optimal solutions found for the minimalist model can be then fine-tuned by experiments and numerical simulations, applicable to realistic conditions that include spatial variability and heterogeneities. @article{mau2016optimal,&nbsp;&nbsp; doi = {10.1016/j.advwatres.2016.02.014},&nbsp;&nbsp; year = {2016},&nbsp;&nbsp; publisher = {Elsevier {BV}},&nbsp;&nbsp; volume = {91},&nbsp;&nbsp; pages = {37--45},&nbsp;&nbsp; author = {Yair Mau and Amilcare Porporato},&nbsp;&nbsp; title = {Optimal control solutions to sodic soil reclamation},&nbsp;&nbsp; journal = {Advances in Water Resources}} Amilcare Porporato, Xue Feng, Stefano Manzoni, Yair Mau, Anthony J. Parolari, and Giulia Vico. Ecohydrological modeling in agroecosystems: Examples and challenges. Water Resources Research, 51(7):5081–5099, 2015. doi: 10.1002/2015WR017289 Abstract   BibTeX   PDF . Human societies are increasingly altering the water and biogeochemical cycles to both improve ecosystem productivity and reduce risks associated with the unpredictable variability of climatic drivers. These alterations, however, often cause large negative environmental consequences, raising the question as to how societies can ensure a sustainable use of natural resources for the future. Here we discuss how ecohydrological modeling may address these broad questions with special attention to agroecosystems. The challenges related to modeling the two-way interaction between society and environment are illustrated by means of a dynamical model in which soil and water quality supports the growth of human society but is also degraded by excessive pressure, leading to critical transitions and sustained societal growth-collapse cycles. We then focus on the coupled dynamics of soil water and solutes (nutrients or contaminants), emphasizing the modeling challenges, presented by the strong nonlinearities in the soil and plant system and the unpredictable hydroclimatic forcing, that need to be overcome to quantitatively analyze problems of soil water sustainability in both natural and agricultural ecosystems. We discuss applications of this framework to problems of irrigation, soil salinization, and fertilization and emphasize how optimal solutions for large-scale, long-term planning of soil and water resources in agroecosystems under uncertainty could be provided by methods from stochastic control, informed by physically and mathematically sound descriptions of ecohydrological and biogeochemical interactions. @article{porporato2015ecohydrological,&nbsp;&nbsp; doi = {10.1002/2015wr017289},&nbsp;&nbsp; year = {2015},&nbsp;&nbsp; publisher = {Wiley-Blackwell},&nbsp;&nbsp; author = {Amilcare Porporato and Xue Feng and Stefano Manzoni and Yair Mau and Anthony J. Parolari and Giulia Vico},&nbsp;&nbsp; title = {Ecohydrological modeling in agroecosystems: Examples and challenges},&nbsp;&nbsp; journal = {Water Resources Research},&nbsp;&nbsp; volume = {51},&nbsp;&nbsp; number = {7},&nbsp;&nbsp; pages = {5081--5099}, } Yair Mau and Amilcare Porporato. A dynamical system approach to soil salinity and sodicity. Advances in Water Resources, 83:68–76, 2015. doi: 10.1016/j.advwatres.2015.05.010 Abstract   BibTeX   PDF . Soil salinity and sodicity impose severe constrains to agriculture, especially in arid and semi-arid regions, where good-quality water for irrigation is scarce. While detailed models have been proposed in the past to describe the dynamics of salt and sodium in the soil, they typically require cumbersome calculations and are not amenable to theoretical analysis. Here we present an analytical model for the dynamics of salinity and sodicity in the root zone. We determine the dependence of steady-state salinity and sodicity levels on irrigation water quality and derive the trajectories in the phase space. The only stationary solution the equations admit is a stable node. Through numerical integration and analysis of the eigenvalues of the derived two-dimensional system of equations, the slower time scale associated with sodification is quantified with respect to the faster time scale associated to salinization. The role of different cation exchange equations (Gapon and Vanselow conventions) are shown to be practically the same with regard to the phase-space dynamics and the time scales. The results can be applied in controlling for low levels of salinity and sodicity, and in planning remediation strategies that are timely and economical. @article{mau2015dynamical,&nbsp;&nbsp; year = {2015},&nbsp;&nbsp; publisher = {Elsevier {BV}},&nbsp;&nbsp; volume = {83},&nbsp;&nbsp; pages = {68--76},&nbsp;&nbsp; author = {Yair Mau and Amilcare Porporato},&nbsp;&nbsp; title = {A dynamical system approach to soil salinity and sodicity},&nbsp;&nbsp; journal = {Advances in Water Resources},&nbsp;&nbsp; doi = {10.1016/j.advwatres.2015.05.010}, } Yair Mau, Lev Haim, and Ehud Meron. Reversing desertification as a spatial resonance problem. Physical Review E, 91(1):012903, 2015. doi: 10.1103/PhysRevE.91.012903 Abstract   BibTeX   PDF . An important environmental application of pattern control by periodic spatial forcing is the restoration of vegetation patterns in water-limited ecosystems that went through desertification. Vegetation restoration is often based on periodic landscape modulations that intercept overland water flow and form favorable conditions for vegetation growth. Viewing this method as a spatial resonance problem, we show that plain realizations of this method, assuming a complete vegetation response to the imposed modulation pattern, suffer from poor resilience to rainfall variability. By contrast, less intuitive realizations, based on the inherent spatial modes of vegetation growth and involving partial vegetation implantation, can be highly resilient and equally productive. We derive these results using two complementary models, a realistic vegetation model, and a simple pattern formation model that lends itself to mathematical analysis and highlights the universal aspects of the behaviors found with the vegetation model. We focus on reversing desertification as an outstanding environmental problem, but the main conclusions hold for any spatially forced system near the onset of a finite-wave-number instability that is subjected to noisy conditions. @article{mau2015reversing,&nbsp;&nbsp; title={Reversing desertification as a spatial resonance problem},&nbsp;&nbsp; author={Yair Mau and Lev Haim and Ehud Meron},&nbsp;&nbsp; journal={Physical Review E},&nbsp;&nbsp; volume={91},&nbsp;&nbsp; number={1},&nbsp;&nbsp; pages={012903},&nbsp;&nbsp; year={2015},&nbsp;&nbsp; publisher={APS},&nbsp;&nbsp; doi = {10.1103/physreve.91.012903}, } Yair Mau, Xue Feng, and Amilcare Porporato. Multiplicative jump processes and applications to leaching of salt and contaminants in the soil. Physical Review E, 90(5):052128, 2014. doi: 10.1103/PhysRevE.90.052128 Abstract   BibTeX   PDF . We consider simple systems driven multiplicatively by white shot noise, which appear in the modeling of the dynamics of soil nutrients and contaminants. The dynamics of these systems is analyzed in two ways: solving a hierarchy of linear ordinary differential equations for the moments, which gives a time scale of convergence of the stationary probability density function; and characterizing the crossing properties, such as the mean first-passage time and the mean frequency of level crossing. These results are readily applicable to the study of geophysical systems, such as the problem of accumulation of salt in the root zone, i.e., soil salinization. @article{mau2014multiplicative,&nbsp;&nbsp; title={Multiplicative jump processes and applications to leaching of salt and contaminants in the soil},&nbsp;&nbsp; author={Yair Mau and Xue Feng and Amilcare Porporato},&nbsp;&nbsp; journal={Physical Review E},&nbsp;&nbsp; volume={90},&nbsp;&nbsp; number={5},&nbsp;&nbsp; pages={052128},&nbsp;&nbsp; year={2014},&nbsp;&nbsp; publisher={APS},&nbsp;&nbsp; doi = {10.1103/physreve.90.052128}, } Lev Haim, Yair Mau, and Ehud Meron. Spatial forcing of pattern-forming systems that lack inversion symmetry. Physical Review E, 90(2):022904, 2014. doi: 10.1103/PhysRevE.90.022904 Abstract   BibTeX   PDF . The entrainment of periodic patterns to spatially periodic parametric forcing is studied. Using a weak nonlinear analysis of a simple pattern formation model we study the resonant responses of one-dimensional systems that lack inversion symmetry. Focusing on the first three n:1 resonances, in which the system adjusts its wavenumber to one nth of the forcing wavenumber, we delineate commonalities and differences among the resonances. Surprisingly, we find that all resonances show multiplicity of stable phase states, including the 1:1 resonance. The phase states in the 2:1 and 3:1 resonances, however, differ from those in the 1:1 resonance in remaining symmetric even when the inversion symmetry is broken. This is because of the existence of a discrete translation symmetry in the forced system. As a consequence, the 2:1 and 3:1 resonances show stationary phase fronts and patterns, whereas phase fronts within the 1:1 resonance are propagating and phase patterns are transients. In addition, we find substantial differences between the 2:1 resonance and the other two resonances. While the pattern forming instability in the 2:1 resonance is supercritical, in the 1:1 and 3:1 resonances it is subcritical, and while the inversion asymmetry extends the ranges of resonant solutions in the 1:1 and 3:1 resonances, it has no effect on the 2:1 resonance range. We conclude by discussing a few open questions. @article{haim2014spatial,&nbsp;&nbsp; title={Spatial forcing of pattern-forming systems that lack inversion symmetry},&nbsp;&nbsp; author={Lev Haim and Yair Mau and Ehud Meron},&nbsp;&nbsp; journal={Physical Review E},&nbsp;&nbsp; volume={90},&nbsp;&nbsp; number={2},&nbsp;&nbsp; pages={022904},&nbsp;&nbsp; year={2014},&nbsp;&nbsp; publisher={APS},&nbsp;&nbsp; doi = {10.1103/physreve.90.022904}, } Yair Mau, Lev Haim, Aric Hagberg, and Ehud Meron. Competing resonances in spatially forced pattern-forming systems. Physical Review E, 88(3): 032917, 2013. doi: 10.1103/PhysRevE.88.032917 Abstract   BibTeX   PDF . Spatial periodic forcing can entrain a pattern-forming system in the same way as temporal periodic forcing can entrain an oscillator. The forcing can lock the pattern&#39;s wave number to a fraction of the forcing wave number within tonguelike domains in the forcing parameter plane, it can increase the pattern&#39;s amplitude, and it can also create patterns below their onset. We derive these results using a multiple-scale analysis of a spatially forced Swift-Hohenberg equation in one spatial dimension. In two spatial dimensions the one-dimensional forcing can induce a symmetry-breaking instability that leads to two-dimensional (2D) patterns, rectangular or oblique. These patterns resonate with the forcing by locking their wave-vector component in the forcing direction to half the forcing wave number. The range of this type of 2:1 resonance overlaps with the 1:1 resonance tongue of stripe patterns. Using a multiple-scale analysis in the overlap region we show that the 2D patterns can destabilize the 1:1 resonant stripes even at exact resonance. This result sheds new light on the use of spatial periodic forcing for controlling patterns. @article{mau2013competing,&nbsp;&nbsp; title={Competing resonances in spatially forced pattern-forming systems},&nbsp;&nbsp; author={Yair Mau and Lev Haim and Aric Hagberg and Ehud Meron},&nbsp;&nbsp; journal={Physical Review E},&nbsp;&nbsp; volume={88},&nbsp;&nbsp; number={3},&nbsp;&nbsp; pages={032917},&nbsp;&nbsp; year={2013},&nbsp;&nbsp; publisher={APS},&nbsp;&nbsp; doi = {10.1103/physreve.88.032917}, } Yair Mau, Aric Hagberg, and Ehud Meron. Spatial periodic forcing can displace patterns it is intended to control. Physical Review Letters, 109 (3):034102, 2012. doi: 10.1103/PhysRevLett.109.034102 Abstract   BibTeX   PDF . Spatial periodic forcing of pattern-forming systems is an important, but lightly studied, method of controlling patterns. It can be used to control the amplitude and wave number of one-dimensional periodic patterns, to stabilize unstable patterns, and to induce them below instability onset. We show that, although in one spatial dimension the forcing acts to reinforce the patterns, in two dimensions it acts to destabilize or displace them by inducing two-dimensional rectangular and oblique patterns. @article{mau2012spatial,&nbsp;&nbsp; title={Spatial periodic forcing can displace patterns it is intended to control},&nbsp;&nbsp; author={Yair Mau and Aric Hagberg and Ehud Meron},&nbsp;&nbsp; journal={Physical Review Letters},&nbsp;&nbsp; volume={109},&nbsp;&nbsp; number={3},&nbsp;&nbsp; pages={034102},&nbsp;&nbsp; year={2012},&nbsp;&nbsp; publisher={APS},&nbsp;&nbsp; doi = {10.1103/physrevlett.109.034102}, } Yair Mau, Aric Hagberg, and Ehud Meron. Dual-mode spiral vortices. Physical Review E, 80(6):065203, 2009. doi: 10.1103/physreve.80.065203 Abstract   BibTeX   PDF . We show that spiral vortices in oscillatory systems can lose stability to secondary modes to form dual-mode spiral vortices. The secondary modes grow at the vortex core where the oscillation amplitude vanishes but are nonlinearly damped by the oscillatory mode away from the core. Gradients of the oscillation phase, induced by the hosted secondary mode, can lead to additional hosting events that culminate in periodic core oscillations or in a novel form of spatiotemporal chaos. The results of this study apply to physical, chemical, and biological systems that go through cusp-Hopf, fold-Hopf, and Hopf-Turing bifurcations. @article{mau2009dual,&nbsp;&nbsp; title={Dual-mode spiral vortices},&nbsp;&nbsp; author={Yair Mau and Aric Hagberg and Ehud Meron},&nbsp;&nbsp; journal={Physical Review E},&nbsp;&nbsp; volume={80},&nbsp;&nbsp; number={6},&nbsp;&nbsp; pages={065203},&nbsp;&nbsp; year={2009},&nbsp;&nbsp; publisher={APS},&nbsp;&nbsp; doi = {10.1103/physreve.80.065203}, } Tip: find the BibTeX of any publication by copying its doi here: doi2bib.org. . Theses . PhD Thesis . Title: “Pattern Formation in Spatially Forced Systems: Application to Vegetation Restoration” Advisor: Prof. Ehud Meron. The Physics Department, The Ben-Gurion University of the Negev, Israel. PDF . Master’s Thesis . Title: “Localized Spatial Strutures in Non-Equilibrium Systems” Advisor: Prof. Ehud Meron. The Physics Department, The Ben-Gurion University of the Negev, Israel. PDF Watch pretty cool videos on this research!! .",
          "url": "https://yairmau.com/publications/",
          "relUrl": "/publications/",
          "date": ""
      }
      
  

  
      ,"page9": {
          "title": "Physics A (extended) - 71031",
          "content": "Physics A (extended) - 71031 . . Some past exams (in hebrew) . 2019-2020 . Midterm Solution . Moed A Solution . Moed B Solution . 2018-2019 . Midterm Solution . Moed A Solution . Moed B Solution . 2017-2018 . Midterm Solution . Moed A Solution . Moed B Solution .",
          "url": "https://yairmau.com/teaching/physics71031/",
          "relUrl": "/teaching/physics71031/",
          "date": ""
      }
      
  

  
      ,"page10": {
          "title": "Surface Hydrology",
          "content": "Surface Hydrology . . Under construction… .",
          "url": "https://yairmau.com/teaching/agrotech/",
          "relUrl": "/teaching/agrotech/",
          "date": ""
      }
      
  

  
      ,"page11": {
          "title": "Five-Star Content I Recommend",
          "content": "Five-Star Content I Recommend . . Books . [Check out my Goodreads profile]. . Superintelligence: Paths, Dangers, Strategies, by Nick Bostrom. | The Unfolding of Language: An Evolutionary Tour of Mankind’s Greatest Invention, by Guy Deutscher. | . Blogs . Wait but why, by Tim Urban. | Fuck Yeah Fluid Dynamics, by Nicole Sharp. | . Short stories . They’re made out of meat, by Terry Bisson. | The Sentinel, by Arthur C. Clarke. | On Exactitude in Science, by Jorge Luis Borges. | The Feeling Of Power , by Isaac Asimov. | . Technical stuff . Linux Shell Scripting Tutorial | Pythonic Perambulations, by Jake VanderPlas. | . YouTube channels . 3Blue1Brown, minute physics, Veritasium, Smarter Every Day, CGP Grey, Kurzgesagt, Primitive Technology, Vsauce, Nerdwriter, Mathologer, Sciencium, Steve Mould . Podcasts . Hardcore History with Dan Carlin, especially the series “Blueprint for Armageddon” and “Wrath of the Khans”. | 99% Invisible | Radiolab | Making Sense, with Sam Harris | .",
          "url": "https://yairmau.com/more/five-stars/",
          "relUrl": "/more/five-stars/",
          "date": ""
      }
      
  

  
      ,"page12": {
          "title": "Teaching",
          "content": "Teaching . . I currently teach the following courses at the Hebrew University of Jerusalem, campus Rehovot. . Physics A (extended) . Surface Hydrology . Agrotech Lab .",
          "url": "https://yairmau.com/teaching/",
          "relUrl": "/teaching/",
          "date": ""
      }
      
  

  
      ,"page13": {
          "title": "Tutorials",
          "content": "Tutorials . . Python tutorial . $ , rightarrow ,$ $ LaTeX$ tutorial .",
          "url": "https://yairmau.com/tutorials/",
          "relUrl": "/tutorials/",
          "date": ""
      }
      
  

  
      ,"page14": {
          "title": "Quotes",
          "content": "Quotes . . The scientist is not a person who gives the right answers, he’s one who asks the right questions. Claude Lévi-Strauss . | The most exciting phrase to hear in science, the one that heralds new discoveries, is not ‘Eureka!’ (I found it!) but ‘That’s funny…’ Isaac Asimov . | In theory, there is no difference between theory and practice. But, in practice, there is. Jan L. A. van de Snepscheut . | Contrary to what Asimov says, the most exciting phrase in science, the one that heralds new discoveries, is not ‘Eureka!’ or ‘That’s funny…,’ it’s ‘Your research grant has been approved.’ John Alejandro King . | A theory is something nobody believes, except the person who made it. An experiment is something everybody believes, except the person who made it. Attributed to Albert Einstein . | The purpose of models is not to fit the data but to sharpen the questions. Samuel Karlin . | Research is what I’m doing when I don’t know what I’m doing. Wernher von Braun . | Nothing is more practical than a good theory. Kurt Lewin . | Just as there are odors that dogs can smell and we cannot, as well as sounds that dogs can hear and we cannot, so too there are wavelengths of light we cannot see and flavors we cannot taste. Why then, given our brains wired the way they are, does the remark, “Perhaps there are thoughts we cannot think,” surprise you? Richard Hamming . | An expert is a person who has made all the mistakes that can be made in a very narrow field. Niels Bohr . | An expert is one who knows more and more about less and less until he knows absolutely everything about nothing. Nicholas Butler . | Essentially, all models are wrong, but some are useful. George E. P. Box . | Theory is when you know everything but nothing works. Praxis is when everything works but no one knows why. In our lab, theory and praxis are combined: nothing works and no one know why. Unknown . | The great tragedy of Science — the slaying of a beautiful hypothesis by an ugly fact. Thomas Henry Huxley . | So, in the face of overwhelming odds, I’m left with only one option, I’m gonna have to science the shit out of this. Mark Watney . | The fact that we live at the bottom of a deep gravity well, on the surface of a gas covered planet going around a nuclear fireball 90 million miles away and think this to be normal is obviously some indication of how skewed our perspective tends to be. Douglas Adams, The Salmon of Doubt: Hitchhiking the Galaxy One Last Time . | You’d be amazed how much research you can get done when you have no life whatsoever. Ernest Cline, Ready Player One . | When you have eliminated all which is impossible, then whatever remains, however improbable, must be the truth. Sherlock Holmes . | With four parameters I can fit an elephant, and with five I can make him wiggle his trunk. John von Neumann . | The purpose of computing is insight, not numbers. Richard Hamming . | The most important thing about an equation is all the quantities that don’t appear in it; once we know what the essentials are, figuring out how they depend on each other is often the easier part. Pedro Domingos, The Master Algorithm . | Thermodynamics is easy – I’ve learned it many times. Harvey S. Leff . | Far better an approximate answer to the right question, which is often vague, than an exact answer to the wrong question, which can always be made precise. John Tukey, The future of data analysis . | An article about computational result is advertising, not scholarship. The actual scholarship is the full software environment, code and data, that produced the result. Buckheit and Donoho (1995) . | ”Forty-two!” yelled Loonquawl. ”Is that all you’ve got to show for seven and a half million years’ work?” ”I checked it very thoroughly,” said the computer, ”and that quite definitely is the answer. I think the problem, to be quite honest with you, is that you’ve never actually known what the question is.” ”But it was the Great Question! The Ultimate Question of Life, the Universe and Everything!” howled Loonquawl. ”Yes,” said Deep Thought with the air of one who suffers fools gladly, ”but what actually is it?” A slow stupefied silence crept over the men as they stared at the computer and then at each other. ”Well, you know, it’s just Everything … Everything … ” offered Phouchg weakly. ”Exactly!” said Deep Thought. ”So once you do know what the question actually is, you’ll know what the answer means.” Douglas Adams, The Hitchiker’s Guide to the Galaxy . | Computers are useless. They can only give you answers. Pablo Picasso . | The true and only goal of science is to reveal unity rather than mechanism. Henri Poincaré . | One of the principal objects of theoretical research is to find the point of view from which the subject appears in the greatest simplicity. Josiah Willard Gibbs . | The future is already here — it’s just not very evenly distributed. William Gibson . | True science teaches, above all, to doubt and to be ignorant. Miguel de Unamuno . | If you are the smartest person in the room, then you are in the wrong room. Unknown . | Dividing one number by another is mere computation; knowing what to divide by what is mathematics. Jordan Ellenberg, How Not to Be Wrong: The Power of Mathematical Thinking . | I’ve been in this argument a thousand times. Won them all and convinced nobody. Amos Tversky, on the hot hand fallacy . | Mathematics is the extension of common sense by other means. Jordan Ellenberg, How Not to Be Wrong: The Power of Mathematical Thinking . | If I had more time, I would have written a shorter letter. Blaise Pascal . | I am going to give what I will call an elementary demonstration. But elementary does not mean easy to understand. Elementary means that very little is required to know ahead of time in order to understand it, except to have an infinite amount of intelligence. There may be a large number of steps that hard to follow, but to each does not require already knowing the calculus or Fourier transforms. Richard P. Feynman . | In this section a mathematical model of the growing embryo will be described. This model will be a simplification and an idealization, and consequently a falsification. It is to be hoped that the features retained for discussion are those of greatest importance in the present state of knowledge. Alan Turing, The Chemical Basis of Morphogenesis . | Problems worthy of attack prove their worth by hitting back. Piet Hein . | Art is solving problems that cannot be formulated before they have been solved. The shaping of the question is part of the answer. Piet Hein . | Physics is the simplest of all the sciences, and fundamental physics⁠⁠—the study of the basic pieces of reality at the deepest level⁠—is the simplest of all. Not “simple” in the sense that the homework problems are easy, but simple in the sense that Galileo’s trick of ignoring friction and air resistance makes our lives easier. The reason why physics classes seem so hard is not because physics is so hard—it’s because we understand so much of it that there’s a lot to learn, and that’s because it’s fundamentally pretty simple. Sean Carroll, The Big Picture . | Simplicity is a great virtue but it requires hard work to achieve it and education to appreciate it. And to make matters worse: complexity sells better. Edsger W. Dijkstra . | The fundamental role of a teacher is not to deliver information. It is guide the social process of learning. The job of a teacher is to inspire, to challenge, to excite their students to want to learn. Yes, they also do explain and demonstrate and show things, but fundamentally that is beside the point. The most important thing a teacher does is make every student feel like they are important, to make them feel accountable for doing the work of learning. Derek Alexander Muller, https://youtu.be/GEmuEWjHr5c . | .",
          "url": "https://yairmau.com/more/quotes/",
          "relUrl": "/more/quotes/",
          "date": ""
      }
      
  

  
      ,"page15": {
          "title": "",
          "content": "Senior Lecturer [Assistant Professor] The Hebrew University of Jerusalem The Department of Soil and Water Sciences Robert H. Smith Faculty of Agriculture, Food and Environment . About . I’m interested in the interactions between soil, water and vegetation in drylands, in both natural and agricultural ecosystems. Our goal is to understand how the basic processes and feedbacks influence the ecosystem dynamics, and how this knowledge can be used to control those systems. . The common theme between my different research projects is land/ecosystem degradation caused by human activity. . Our research is based on “simple” mathematical models, that strive to capture the essential physical processes, while providing deep insight into the dynamics of the system. Some of the tools we use in the modeling of environmental questions come from dynamical systems, statistical physics and optimal control theory. . [Read more on current research projects…] . I love to write code, and I made available on the Tutorials page some working examples in Python and LaTeX. Check it out! . How to find me .   yair.mau@mail.huji.ac.il   +972 8 948 9386   Rehovot Campus, Lubell building, office 19. Map here . Google Scholar Check out my CV . . Piet Hein Problems worthy   of attack prove their worth   by hitting back. .",
          "url": "https://yairmau.com/",
          "relUrl": "/",
          "date": ""
      }
      
  

  
      ,"page16": {
          "title": "Python",
          "content": "Python . . Python is a great language for scientific computing, most of the programming done by our group is in python. We provide below some links for learning this language, and below we offer many python code examples. You are invited to download these codes, tweak with them, break them, hack them as you wish! . Most codes focus on plotting, but other algorithms such as numerical integration and Fourier transforms can also be found. . Some useful links for learning python: . Python Data Science Handbook | Learn Python the Hard Way | A Crash Course in Python for Scientists | Software Carpentry | Fun with Lists | Python | Codecademy | Scipy Lecture Notes | A gallery of interesting IPython Notebooks | Think Python: How to Think Like a Computer Scientist | The Python Graph Gallery | . This might be overwhelming, so I suggest you to follow this: . My advice on learning Python:Don&#39;t set out to &quot;learn Python&quot;. Choose a problem you&#39;re interested in and learn to solve it with Python. . &mdash; Jake VanderPlas (@jakevdp) September 10, 2017 Start by downloading Anaconda, a package manager application that will help you get started with python in all platforms. . Make sure you are acquainted with ipython (interactive python, try it here), and with Jupyter notebook. ​ . I recommend Sublime Text for writing code, and you can install the Anaconda package to it to have a smooth IDE. [not the same anaconda as mentioned above! Yes, it’s confusing, I know.] . . Fitzhugh-Nagumo — Labyrinthine Patterns . Jupyter notebook . Main features: how to make a movie, time-integration methods (semi-spectral and Euler) . . Conway’s Game of Life, acorn initial conditionnn . Jupyter notebook . This is a (slightly) modified version of Glowing Python’s code. I make it available here because it features a few nice things: . how to make a movie using matplotlib.animation | how to write a generator (function with yield) | how to plot a sparce array (spy) | . Main features: matplotlib.animation, yield, with, matplotlib.pyplot.spy . . Least squares fit of nonlinear function . Jupyter notebook . Main features: LaTeX text, scipy.optimize.curve_fit, matplotlib.patches . . Fun with histograms . Jupyter notebook . Main features: np.histogram, plt.hist, plt.bar, plt.barh, gridspec, least squares fit of nonlinear function, plt.hist2d . . Fancy subplot grid . Jupyter notebook . Highly customizable subplot structure. Also, figure contains several axis configurations and labeling options. Main features: gridspec subplots; numpy-compatible heaviside; label, ticks and axis manipulations; log scale . . Streamplot . Jupyter notebook . Streamplot of a two-dimensional linear system, with eigenvectors and nullclines. Python shows LaTeX equations beautifully. Main features: meshgrid, streamplot, contour, legend, LaTeX . . The time dependent Ginzburg-Landau equation . Jupyter notebook . Numerical integration of a parabolic partial differential equation, using finite differences: Euler step to advance time, and a 5-point stencil to approximate the Laplacian. Main features: imshow, colorbar, set_data . . The double pendulum . Jupyter notebook . Numerical integration of the equations of motion of the double pendulum. This time, scipy’s ode itegrator was used. Nice example of how to make a movie. Main features: scipy.integrate.ode, set_data, set_aspect(&#39;equal&#39;), remove plot, movie . . The Hilbert curve . Jupyter notebook . Construction of the Hilbert curve as a Lindenmayer system (L-system). Main features: string operations, movie . . A hysteresis mechanism . Jupyter notebook . Hysteresis mechanism created by the bistability of states. System goes to minimum points u in the energy functional $f=u^4-2u^2+hu$. The parameter $h$ is ramped down and up during this simulation. Main features: sympy analytical calculations, numpy dtypes, movie . . Contour plot . Jupyter notebook . Contour plot with many customizable options. Also, a nice way to truncate a colormap so it gives the color range that you want. Main features: truncate_colormap, contour, contourf (fill), clabel (contour label) . . . Least action principle on the beach . Jupyter notebook . How should ​lifeguard run in order to save a drowning person in minimal time? Answer: by using Snell’s law of refraction! This is a nice example how to use spines (x and y axis form a cross), instead of rectangular figures as usual. Also, “annotations” are used, where things can be labeled with the help of arrows. Main features: spines, matplotlib.patches.Rectangle, annotate . . . This website’s logo . Jupyter notebook . Simple example of how to make a figure without any visible axes. Main features: set_axis_off, fill_between, matplotlib inline plot on Jupyter . . . Bars . Jupyter notebook . Horizontal and vertical bars, with numeric legends. Unicode support. Main features: unicode, bar, barh, grid . .",
          "url": "https://yairmau.com/tutorials/python/",
          "relUrl": "/tutorials/python/",
          "date": ""
      }
      
  

  
      ,"page17": {
          "title": "LaTeX",
          "content": "$ LaTeX$ . . Equations . With $ LaTeX$ you can write beautiful equations like . Rμν−12gμν R+gμνΛ=8πGc4TμνR_{ mu nu} - {1 over 2}g_{ mu nu} ,R + g_{ mu nu} Lambda = displaystyle{8 pi G over c^4} T_{ mu nu}Rμν​−21​gμν​R+gμν​Λ=c48πG​Tμν​ or ϕ=1+11+11+⋯=1+52 phi = 1 + cfrac{1}{1+ cfrac{1}{1+ dotsb}}= frac{1+ sqrt{5}}{2}ϕ=1+1+1+⋯1​1​=21+5​​ . Learn more here. . Presentation . Make beautiful presentations using Beamer! Download a full working example of my favorite template [zip] [overleaf]. Browse the presentation below to get an idea. . Posters . Make beautiful posters with LaTeX. Portrait [zip] [overleaf] Landscape [zip] [overleaf] . . PhD Thesis . This template is based on my PhD thesis, it can make your life easier! . Download [zip] [overleaf]. | Don’t forget to read the file README.txt | Enjoy! | Hebrew . A LaTeX document with Hebrew text. Download .tex source here, and the pdf here. . See below a really practical use of the tools provided above. This is an exercise list in hebrew. Download .tex source here, and the pdf here. .",
          "url": "https://yairmau.com/tutorials/latex/",
          "relUrl": "/tutorials/latex/",
          "date": ""
      }
      
  

  
      ,"page18": {
          "title": "Group",
          "content": "Group . . Yair Mau, Principal Investigator . . . Isaac Kramer, PhD student . . . Nurit Goldberg, PhD student . . . Michael Avi Gross, MSc student . . . Taiwo Adeyemo, MSc student . . . Avigail Kaner, Research Specialist . . . Group Pictures . 2020-03-18, First Corona zoom meeting . . 2019-05-21, Avigail teaching electromagnetism . The automatic subtitle system took some liberty there 🤣 The original sentence was . השיטה הזאת של B , v ו-F האגודל נותנת את הכיוון של v קרוס B . . 2019-01-10, Yatir Forest . Avi Gross, Avigail Kaner, Isaac Kramer, Yair Mau .",
          "url": "https://yairmau.com/group/",
          "relUrl": "/group/",
          "date": ""
      }
      
  

  

  
  

  
  

  
  

  
  

  
  

  
      ,"page25": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://yairmau.com/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}